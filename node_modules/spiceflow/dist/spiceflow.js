import { copy } from 'copy-anything';
import superjson from 'superjson';
import { ValidationError } from "./error.js";
import OriginalRouter from '@medley/router';
import { ZodType } from 'zod';
import { handleForNode, listenForNode } from 'spiceflow/_node-server';
import { isAsyncIterable, isResponse, redirect } from "./utils.js";
let globalIndex = 0;
const notFoundHandler = (c) => {
    return new Response('Not Found', { status: 404 });
};
export class Spiceflow {
    id = globalIndex++;
    router = new OriginalRouter();
    middlewares = [];
    onErrorHandlers = [];
    routes = [];
    defaultState = {};
    topLevelApp = this;
    waitUntilFn;
    disableSuperJsonUnlessRpc = false;
    _types = {
        Prefix: '',
        ClientRoutes: {},
        RoutePaths: '',
        Scoped: false,
        Singleton: {},
        Definitions: {},
        Metadata: {},
    };
    /** @internal */
    basePath = '';
    /** @internal */
    childrenApps = [];
    /** @internal */
    getAllRoutes() {
        let root = this.topLevelApp || this;
        const allApps = bfs(root) || [];
        const allRoutes = allApps.flatMap((x) => {
            const prefix = this.joinBasePaths(this.getAppAndParents(x).map((x) => x.basePath));
            return x.routes.map((x) => ({ ...x, path: prefix + x.path }));
        });
        return allRoutes;
    }
    add({ method, path, hooks, handler, ...rest }) {
        let bodySchema = hooks?.request || hooks?.body;
        let validateBody = getValidateFunction(bodySchema);
        let validateQuery = getValidateFunction(hooks?.query);
        let validateParams = getValidateFunction(hooks?.params);
        if (typeof handler === 'function' && !handler.name) {
            Object.defineProperty(handler, 'name', {
                value: path,
                configurable: true,
            });
        }
        // remove trailing slash which can cause problems
        path = path?.replace(/\/$/, '') || '/';
        const store = this.router.register(path);
        let route = {
            ...rest,
            type: hooks?.type || '',
            method: (method || ''),
            path: path || '',
            handler: handler,
            hooks,
            validateBody,
            validateParams,
            validateQuery,
        };
        this.routes.push(route);
        store[method] = route;
    }
    match(method, path) {
        let root = this;
        let foundApp;
        // remove trailing slash which can cause problems
        path = path.replace(/\/$/, '') || '/';
        const result = bfsFind(this, (app) => {
            app.topLevelApp = root;
            let prefix = this.joinBasePaths(this.getAppAndParents(app).map((x) => x.basePath)).replace(/\/$/, '');
            if (prefix && !path.startsWith(prefix)) {
                return;
            }
            let pathWithoutPrefix = path;
            if (prefix) {
                pathWithoutPrefix = path.replace(prefix, '') || '/';
            }
            const medleyRoute = app.router.find(pathWithoutPrefix);
            if (!medleyRoute) {
                foundApp = app;
                return;
            }
            let internalRoute = medleyRoute.store[method];
            if (internalRoute) {
                const params = medleyRoute.params || {};
                const res = {
                    app,
                    internalRoute: internalRoute,
                    params,
                };
                return res;
            }
            if (method === 'HEAD') {
                let internalRouteGet = medleyRoute.store['GET'];
                if (!internalRouteGet?.handler) {
                    return;
                }
                return {
                    app,
                    internalRoute: {
                        hooks: {},
                        handler: async (c) => {
                            const response = await internalRouteGet.handler(c);
                            if (isResponse(response)) {
                                return new Response('', {
                                    status: response.status,
                                    statusText: response.statusText,
                                    headers: response.headers,
                                });
                            }
                            return new Response(null, { status: 200 });
                        },
                        method,
                        path,
                    },
                    params: medleyRoute.params,
                };
            }
        });
        return (result || {
            app: foundApp || root,
            internalRoute: {
                hooks: {},
                handler: notFoundHandler,
                method,
                path,
            },
            params: {},
        });
    }
    state(name, value) {
        this.defaultState[name] = value;
        return this;
    }
    /**
     * Create a new Router
     * @param options {@link RouterOptions} {@link Platform}
     */
    constructor(options = {}) {
        this.scoped = options.scoped;
        this.disableSuperJsonUnlessRpc = options.disableSuperJsonUnlessRpc || false;
        // Set up waitUntil function - use provided one, global one, or noop
        this.waitUntilFn =
            options.waitUntil ||
                (typeof globalThis !== 'undefined' && 'waitUntil' in globalThis
                    ? globalThis.waitUntil
                    : () => { });
        this.basePath = options.basePath || '';
        if (this.basePath === '/') {
            this.basePath = '';
        }
    }
    post(path, handler, hook) {
        this.add({ method: 'POST', path, handler: handler, hooks: hook });
        return this;
    }
    get(path, handler, hook) {
        this.add({ method: 'GET', path, handler: handler, hooks: hook });
        return this;
    }
    put(path, handler, hook) {
        this.add({ method: 'PUT', path, handler: handler, hooks: hook });
        return this;
    }
    route(options) {
        // If options.request is defined, disallow for GET and HEAD (methods that don't support a body)
        const methodsWithNoBody = ['GET', 'HEAD'];
        const actualMethod = options.method ?? '*';
        const normalizedMethods = Array.isArray(actualMethod)
            ? actualMethod.flatMap((m) => {
                const method = typeof m === 'string' ? m.toUpperCase() : m;
                return method === '*' ? [...METHODS] : [method];
            })
            : (() => {
                const method = typeof actualMethod === 'string'
                    ? actualMethod.toUpperCase()
                    : actualMethod;
                return method === '*' ? [...METHODS] : [method];
            })();
        if (options.request &&
            normalizedMethods.some((m) => methodsWithNoBody.includes(m))) {
            throw new Error(`Request schema ('request') is not allowed on routes with method GET or HEAD`);
        }
        if (Array.isArray(actualMethod)) {
            actualMethod.map((method) => {
                if (method === '*') {
                    for (const m of METHODS) {
                        this.add({
                            method: m,
                            path: options.path,
                            handler: options.handler,
                            hooks: options,
                        });
                    }
                }
                else {
                    this.add({
                        method,
                        path: options.path,
                        handler: options.handler,
                        hooks: options,
                    });
                }
            });
        }
        else {
            if (actualMethod === '*') {
                for (const method of METHODS) {
                    this.add({
                        method,
                        path: options.path,
                        handler: options.handler,
                        hooks: options,
                    });
                }
            }
            else {
                this.add({
                    method: actualMethod,
                    path: options.path,
                    handler: options.handler,
                    hooks: options,
                });
            }
        }
        return this;
    }
    patch(path, handler, hook) {
        this.add({ method: 'PATCH', path, handler: handler, hooks: hook });
        return this;
    }
    delete(path, handler, hook) {
        this.add({ method: 'DELETE', path, handler: handler, hooks: hook });
        return this;
    }
    options(path, handler, hook) {
        this.add({ method: 'OPTIONS', path, handler: handler, hooks: hook });
        return this;
    }
    all(path, handler, hook) {
        for (const method of METHODS) {
            this.add({ method, path, handler: handler, hooks: hook });
        }
        return this;
    }
    head(path, handler, hook) {
        this.add({ method: 'HEAD', path, handler: handler, hooks: hook });
        return this;
    }
    scoped = true;
    use(appOrHandler) {
        if (appOrHandler instanceof Spiceflow) {
            appOrHandler.topLevelApp = this;
            // Inherit disableSuperJsonUnlessRpc from parent if child doesn't have it set
            if (this.disableSuperJsonUnlessRpc === true) {
                appOrHandler.disableSuperJsonUnlessRpc = true;
            }
            this.childrenApps.push(appOrHandler);
        }
        else if (typeof appOrHandler === 'function') {
            this.middlewares ??= [];
            this.middlewares.push(appOrHandler);
        }
        return this;
    }
    onError(handler) {
        this.onErrorHandlers ??= [];
        this.onErrorHandlers.push(handler);
        return this;
    }
    handle = async (request, { state: customState } = {}) => {
        let u = new URL(request.url, 'http://localhost');
        const self = this;
        let path = u.pathname + u.search;
        const defaultContext = {
            redirect,
            error: null,
            path,
        };
        const root = this.topLevelApp || this;
        let onErrorHandlers = [];
        const route = this.match(request.method, path);
        const appsInScope = this.getAppsInScope(route.app);
        onErrorHandlers = appsInScope.flatMap((x) => x.onErrorHandlers);
        let { params: _params, app: { defaultState }, } = route;
        const middlewares = appsInScope.flatMap((x) => x.middlewares);
        let state = customState || copy(defaultState);
        let content = route?.internalRoute?.hooks?.content;
        if (route.internalRoute?.validateBody) {
            // TODO don't clone the request
            let typedRequest = request instanceof SpiceflowRequest
                ? request
                : new SpiceflowRequest(u, request);
            typedRequest.validateBody = route.internalRoute?.validateBody;
            request = typedRequest;
        }
        let index = 0;
        // Wrap waitUntil with error handling
        const wrappedWaitUntil = (promise) => {
            const wrappedPromise = promise.catch(async (error) => {
                const spiceflowError = error instanceof Error ? error : new Error(String(error));
                await this.runErrorHandlers({
                    context: { ...defaultContext, state, request, path, redirect },
                    onErrorHandlers: onErrorHandlers,
                    error: spiceflowError,
                    request,
                });
            });
            return this.waitUntilFn(wrappedPromise);
        };
        let context = {
            ...defaultContext,
            request,
            state,
            path,
            query: parseQuery((u.search || '').slice(1)),
            params: _params,
            redirect,
            waitUntil: wrappedWaitUntil,
        };
        let handlerResponse;
        async function getResForError(err) {
            if (isResponse(err))
                return err;
            let res = await self.runErrorHandlers({
                context,
                onErrorHandlers,
                error: err,
                request,
            });
            if (isResponse(res))
                return res;
            let status = err?.status ?? err?.statusCode ?? 500;
            // Ensure status is a valid HTTP status code (100-599)
            if (typeof status !== 'number' || status < 100 || status > 599) {
                status = 500;
            }
            res ||= new Response(self.superjsonSerialize({
                ...err,
                message: err?.message || 'Internal Server Error',
            }, false, request), {
                status,
                headers: {
                    'content-type': 'application/json',
                },
            });
            return res;
        }
        const next = async () => {
            try {
                if (index < middlewares.length) {
                    const middleware = middlewares[index];
                    index++;
                    const result = await middleware(context, next);
                    if (isResponse(result)) {
                        handlerResponse = result;
                    }
                    if (!result && index < middlewares.length) {
                        return await next();
                    }
                    else if (result) {
                        return await self.turnHandlerResultIntoResponse(result, route.internalRoute, request);
                    }
                }
                if (handlerResponse) {
                    return handlerResponse;
                }
                context.query = await runValidation(context.query, route.internalRoute?.validateQuery);
                context.params = await runValidation(context.params, route.internalRoute?.validateParams);
                const res = await route.internalRoute?.handler.call(this, context);
                if (isAsyncIterable(res)) {
                    handlerResponse = await this.handleStream({
                        generator: res,
                        request,
                        onErrorHandlers,
                        route: route.internalRoute,
                    });
                    return handlerResponse;
                }
                handlerResponse = await self.turnHandlerResultIntoResponse(res, route.internalRoute, request);
                return handlerResponse;
            }
            catch (err) {
                handlerResponse = await getResForError(err);
                return await next();
            }
        };
        const response = await next();
        return response;
    };
    superjsonSerialize(value, indent = false, request) {
        const isRpcRequest = request?.headers.get('x-spiceflow-agent') === 'spiceflow-client';
        // If flag is set and this is not an RPC request, use regular JSON
        if (this.disableSuperJsonUnlessRpc && !isRpcRequest) {
            return JSON.stringify(value, null, indent ? 2 : undefined);
        }
        // Otherwise use superjson
        const { json, meta } = superjson.serialize(value);
        if (json && meta) {
            json['__superjsonMeta'] = meta;
        }
        return JSON.stringify(json ?? null, null, indent ? 2 : undefined);
    }
    async turnHandlerResultIntoResponse(result, route, request) {
        // if user returns a promise, await it
        if (result instanceof Promise) {
            result = await result;
        }
        if (isResponse(result)) {
            return result;
        }
        if (route.type) {
            if (route.type?.includes('multipart/form-data')) {
                if (!(result instanceof Response)) {
                    throw new Error(`Invalid form data returned from route handler ${route.path} - expected Response but got ${result?.constructor?.name || typeof result}. FormData cannot be returned directly - it must be wrapped in a Response object with the appropriate content-type header.`);
                }
            }
            if (route.type?.includes('application/x-www-form-urlencoded')) {
                if (!(result instanceof URLSearchParams)) {
                    throw new Error(`Invalid URL encoded data returned from route handler ${route.path} - expected URLSearchParams but got ${result?.constructor?.name || typeof result}`);
                }
                return new Response(result, {
                    headers: {
                        'content-type': 'application/x-www-form-urlencoded',
                    },
                });
            }
            if (route.type?.includes('text/plain')) {
                if (typeof result !== 'string') {
                    throw new Error(`Invalid text returned from route handler ${route.path} - expected string but got ${result?.constructor?.name || typeof result}`);
                }
                return new Response(result, {
                    headers: {
                        'content-type': 'text/plain',
                    },
                });
            }
        }
        return new Response(this.superjsonSerialize(result, false, request), {
            headers: {
                'content-type': 'application/json',
            },
        });
    }
    async runErrorHandlers({ context, onErrorHandlers = [], error: err, request, }) {
        if (onErrorHandlers.length === 0) {
            console.error(`Spiceflow unhandled error:`, err);
        }
        else {
            for (const errHandler of onErrorHandlers) {
                const path = new URL(request.url).pathname;
                const res = errHandler({ path, ...context, error: err, request });
                if (isResponse(res)) {
                    return res;
                }
            }
        }
    }
    joinBasePaths(basePaths) {
        // Filter out empty/undefined paths and remove consecutive duplicates
        const filteredPaths = basePaths
            .filter((path) => path !== undefined && path !== '')
            .filter((path, index, arr) => index === 0 || path !== arr[index - 1]);
        // Skip paths that are prefixes of the previous path (parent is prefix of child)
        const result = [];
        for (let i = 0; i < filteredPaths.length; i++) {
            const currentPath = filteredPaths[i];
            const previousPath = result[result.length - 1];
            // Skip if the previous path is a prefix of the current path
            if (previousPath && currentPath.startsWith(previousPath)) {
                // Replace the previous path with the current path (which is longer)
                result[result.length - 1] = currentPath;
            }
            else {
                result.push(currentPath);
            }
        }
        return result.join('');
    }
    getAppAndParents(currentApp) {
        let root = this.topLevelApp || this;
        if (!root.childrenApps.length) {
            return [root];
        }
        const parents = [];
        let current = currentApp;
        const parentMap = new Map();
        bfsFind(root, (node) => {
            for (const child of node.childrenApps) {
                parentMap.set(child.id, node);
            }
        });
        // Traverse the parent map to get the parents
        while (current) {
            parents.unshift(current);
            current = parentMap.get(current.id);
        }
        return parents.filter((x) => x !== undefined);
    }
    getAppsInScope(currentApp) {
        let root = this.topLevelApp || this;
        if (!root.childrenApps.length) {
            return [root];
        }
        const withParents = this.getAppAndParents(currentApp);
        const wantedOrder = bfs(root);
        const scopeFalseApps = wantedOrder.filter((x) => x.scoped === false);
        let appsInScope = [];
        for (const app of wantedOrder) {
            if (scopeFalseApps.includes(app)) {
                appsInScope.push(app);
                continue;
            }
            if (withParents.includes(app)) {
                appsInScope.push(app);
                continue;
            }
        }
        return appsInScope;
    }
    async listen(port, hostname = '0.0.0.0') {
        const app = this;
        if (typeof Bun !== 'undefined') {
            const server = Bun.serve({
                port,
                development: (Bun.env.NODE_ENV ?? Bun.env.ENV) !== 'production',
                hostname,
                reusePort: true,
                error(error) {
                    console.error(error);
                    return new Response(app.superjsonSerialize({ message: 'Internal Server Error' }), {
                        status: 500,
                    });
                },
                async fetch(request) {
                    const res = await app.handle(request);
                    return res;
                },
            });
            process.on('beforeExit', () => {
                server.stop();
            });
            const displayedHost = server.hostname === '0.0.0.0' ? 'localhost' : server.hostname;
            console.log(`Listening on http://${displayedHost}:${server.port}`);
            return { port: server.port, server };
        }
        return this.listenForNode(port, hostname);
    }
    /**
     * @deprecated Use `handleForNode` instead.
     */
    async handleNode(req, res, context = {}) {
        return this.handleForNode(req, res, context);
    }
    handleForNode = (req, res, context = {}) => {
        return handleForNode(this, req, res, context);
    };
    /* @deprecated */
    async listenForNode(port, hostname = '0.0.0.0') {
        if (typeof Bun !== 'undefined') {
            console.warn("Server is being started with node:http but the current runtime is Bun, not Node. Consider using the method 'handle' with 'Bun.serve' instead.");
        }
        return listenForNode(this, port, hostname);
    }
    async handleStream({ onErrorHandlers, generator, request, route, }) {
        let init = generator.next();
        if (init instanceof Promise)
            init = await init;
        if (init?.done) {
            return new Response('event: message\ndata: ' +
                this.superjsonSerialize(init.value, false, request) +
                '\n\n' +
                'event: done\n\n', {
                headers: {
                    'Content-Type': 'text/event-stream',
                    'Cache-Control': 'no-cache',
                },
            });
        }
        let self = this;
        return new Response(new ReadableStream({
            async start(controller) {
                let end = false;
                // Set up ping interval
                const pingInterval = setInterval(() => {
                    if (!end) {
                        controller.enqueue(Buffer.from('\n'));
                    }
                }, 10 * 1000);
                request?.signal.addEventListener('abort', async () => {
                    end = true;
                    clearInterval(pingInterval);
                    // Using return() instead of throw() because:
                    // 1. return() allows for cleanup in finally blocks
                    // 2. throw() would trigger error handling which isn't needed for normal aborts
                    // 3. return() is the more graceful way to stop iteration
                    if ('return' in generator) {
                        try {
                            await generator.return(undefined);
                        }
                        catch {
                            // Ignore errors from stopping generator
                        }
                    }
                    try {
                        controller.close();
                    }
                    catch {
                        // nothing
                    }
                });
                if (init?.value !== undefined && init?.value !== null)
                    controller.enqueue(Buffer.from('event: message\ndata: ' +
                        self.superjsonSerialize(init.value, false, request) +
                        '\n\n'));
                try {
                    for await (const chunk of generator) {
                        if (end)
                            break;
                        if (chunk === undefined || chunk === null)
                            continue;
                        controller.enqueue(Buffer.from('event: message\ndata: ' +
                            self.superjsonSerialize(chunk, false, request) +
                            '\n\n'));
                    }
                }
                catch (error) {
                    let res = await self.runErrorHandlers({
                        context: {},
                        onErrorHandlers: onErrorHandlers,
                        error,
                        request,
                    });
                    controller.enqueue(Buffer.from('event: error\ndata: ' +
                        self.superjsonSerialize({
                            ...error,
                            message: error.message || error.name || 'Error',
                        }, false, request) +
                        '\n\n'));
                }
                clearInterval(pingInterval);
                try {
                    controller.close();
                }
                catch {
                    // nothing
                }
            },
        }), {
            headers: {
                'transfer-encoding': 'chunked',
                'content-type': 'text/event-stream; charset=utf-8',
            },
        });
    }
    safePath(path, ...rest) {
        let params = (rest.length > 0 ? rest[0] : undefined);
        let result = path;
        // Handle all provided parameters
        if (params && typeof params === 'object') {
            Object.entries(params).forEach(([key, value]) => {
                if (key === '*') {
                    // Replace wildcard
                    result = result.replace(/\*/, String(value));
                }
                else {
                    // Replace named parameters as before
                    const regex = new RegExp(`:${key}`, 'g');
                    result = result.replace(regex, String(value));
                }
            });
        }
        return result;
    }
}
const METHODS = [
    'ALL',
    'CONNECT',
    'DELETE',
    'GET',
    'HEAD',
    'OPTIONS',
    'PATCH',
    'POST',
    'PUT',
    'TRACE',
];
function bfsFind(tree, onNode) {
    const queue = [tree];
    while (queue.length > 0) {
        const node = queue.shift();
        const result = onNode(node);
        if (result) {
            return result;
        }
        queue.push(...node.childrenApps);
    }
    return;
}
export class SpiceflowRequest extends Request {
    validateBody;
    async json() {
        const body = (await super.json());
        return runValidation(body, this.validateBody);
    }
}
export function bfs(tree) {
    const queue = [tree];
    let nodes = [];
    while (queue.length > 0) {
        const node = queue.shift();
        if (node) {
            nodes.push(node);
        }
        // const result = onNode(node)
        if (node?.childrenApps?.length) {
            queue.push(...node.childrenApps);
        }
    }
    return nodes;
}
export function isZodSchema(value) {
    return (value instanceof ZodType ||
        (typeof value === 'object' &&
            value !== null &&
            'parse' in value &&
            'safeParse' in value &&
            'optional' in value &&
            'nullable' in value));
}
/** `true` ⇒ the value was created by Zod 4, `false` ⇒ Zod 3 */
export function isZod4(schema) {
    return '_zod' in schema; // ⇦ only v4 adds this marker
}
function getValidateFunction(schema) {
    if (!schema) {
        return;
    }
    try {
        return schema['~standard'].validate;
    }
    catch (error) {
        console.log(`not a standard schema: ${schema}`);
        return undefined;
    }
}
async function runValidation(value, validate) {
    if (!validate)
        return value;
    let result = validate(value);
    if (result instanceof Promise) {
        result = await result;
    }
    if (result.issues && result.issues.length > 0) {
        const errorMessages = result.issues
            .map((issue) => {
            let pathString = '';
            if (issue.path && issue.path.length > 0) {
                pathString = issue.path.join('.') + ': ';
            }
            return pathString + issue.message;
        })
            .join('\\n');
        throw new ValidationError(errorMessages || 'Validation failed');
    }
    if ('value' in result) {
        return result.value;
    }
    return value;
}
function parseQuery(queryString) {
    // Create a URLSearchParams instance
    const params = new URLSearchParams(queryString);
    // Convert to an object with arrays for repeated keys
    const paramsObject = {};
    for (const [key, value] of params) {
        // If the key already exists, convert to an array or push to the existing array
        if (paramsObject[key]) {
            paramsObject[key] = Array.isArray(paramsObject[key])
                ? [...paramsObject[key], value]
                : [paramsObject[key], value];
        }
        else {
            paramsObject[key] = value; // Set the value if it's the first occurrence
        }
    }
    return paramsObject;
}
export function cloneDeep(x) {
    return copy(x);
}
//# sourceMappingURL=spiceflow.js.map