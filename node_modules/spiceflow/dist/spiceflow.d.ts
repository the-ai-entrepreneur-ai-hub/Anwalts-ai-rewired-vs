import { SpiceflowFetchError } from './client/errors.ts';
import { ValidationError } from './error.ts';
import { ComposeSpiceflowResponse, ContentType, CreateClient, DefinitionBase, ErrorHandler, ExtractParamsFromPath, GetRequestSchema, HTTPMethod, InlineHandler, InputSchema, IsAny, JoinPath, LocalHook, MetadataBase, MiddlewareHandler, Reconcile, ResolvePath, RouteBase, RouteSchema, SingletonBase, UnwrapRoute } from './types.ts';
import { ZodType } from 'zod';
import { StandardSchemaV1 } from '@standard-schema/spec';
import type { IncomingMessage, ServerResponse } from 'node:http';
export type SpiceflowServerError = ValidationError | SpiceflowFetchError<number, any> | Error;
export type WaitUntil = (promise: Promise<any>) => void;
type ValidationFunction = (value: unknown) => StandardSchemaV1.Result<any> | Promise<StandardSchemaV1.Result<any>>;
export type InternalRoute = {
    method: HTTPMethod;
    path: string;
    type: ContentType;
    handler: InlineHandler<any, any, any, any>;
    hooks: LocalHook<any, any, any, any, any, any, any>;
    validateBody?: ValidationFunction;
    validateQuery?: ValidationFunction;
    validateParams?: ValidationFunction;
};
export declare class Spiceflow<const in out BasePath extends string = '', const in out Scoped extends boolean = true, const in out Singleton extends SingletonBase = {
    state: {};
}, const in out Definitions extends DefinitionBase = {
    type: {};
    error: {};
}, const in out Metadata extends MetadataBase = {
    schema: {};
    macro: {};
    macroFn: {};
}, const out ClientRoutes extends RouteBase = {}, const out RoutePaths extends string = ''> {
    private id;
    private router;
    private middlewares;
    private onErrorHandlers;
    private routes;
    private defaultState;
    topLevelApp?: AnySpiceflow;
    private waitUntilFn;
    private disableSuperJsonUnlessRpc;
    _types: {
        Prefix: BasePath;
        ClientRoutes: ClientRoutes;
        RoutePaths: RoutePaths;
        Scoped: Scoped;
        Singleton: Singleton;
        Definitions: Definitions;
        Metadata: Metadata;
    };
    /** @internal */
    basePath?: string;
    /** @internal */
    childrenApps: AnySpiceflow[];
    /** @internal */
    getAllRoutes(): {
        path: string;
        method: HTTPMethod;
        type: ContentType;
        handler: InlineHandler<any, any, any, any>;
        hooks: LocalHook<any, any, any, any, any, any, any>;
        validateBody?: ValidationFunction;
        validateQuery?: ValidationFunction;
        validateParams?: ValidationFunction;
    }[];
    private add;
    private match;
    state<const Name extends string | number | symbol, Value>(name: Name, value?: Value): Spiceflow<BasePath, Scoped, {
        state: Reconcile<Singleton['state'], {
            [name in Name]: Value;
        }>;
    }, Definitions, Metadata, ClientRoutes, RoutePaths>;
    /**
     * Create a new Router
     * @param options {@link RouterOptions} {@link Platform}
     */
    constructor(options?: {
        name?: string;
        scoped?: Scoped;
        waitUntil?: WaitUntil;
        basePath?: BasePath;
        disableSuperJsonUnlessRpc?: boolean;
    });
    post<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends UnwrapRoute<LocalSchema, Definitions['type']>, const Handle extends InlineHandler<this, Schema, Singleton, JoinPath<BasePath, Path>>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton, Definitions['error'], Metadata['macro'], JoinPath<BasePath, Path>>): Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, ClientRoutes & CreateClient<JoinPath<BasePath, Path>, {
        post: {
            request: GetRequestSchema<Schema>;
            params: undefined extends Schema['params'] ? ResolvePath<Path> : Schema['params'];
            query: Schema['query'];
            response: ComposeSpiceflowResponse<Schema['response'], Handle>;
        };
    }>, RoutePaths | JoinPath<BasePath, Path>>;
    get<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends UnwrapRoute<LocalSchema, Definitions['type']>, const Macro extends Metadata['macro'], const Handle extends InlineHandler<this, Schema, Singleton, JoinPath<BasePath, Path>>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton, Definitions['error'], Macro, JoinPath<BasePath, Path>>): Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, ClientRoutes & CreateClient<JoinPath<BasePath, Path>, {
        get: {
            request: GetRequestSchema<Schema>;
            params: undefined extends Schema['params'] ? ResolvePath<Path> : Schema['params'];
            query: Schema['query'];
            response: ComposeSpiceflowResponse<Schema['response'], Handle>;
        };
    }>, RoutePaths | JoinPath<BasePath, Path>>;
    put<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends UnwrapRoute<LocalSchema, Definitions['type']>, const Handle extends InlineHandler<this, Schema, Singleton, JoinPath<BasePath, Path>>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton, Definitions['error'], Metadata['macro'], JoinPath<BasePath, Path>>): Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, ClientRoutes & CreateClient<JoinPath<BasePath, Path>, {
        put: {
            request: GetRequestSchema<Schema>;
            params: undefined extends Schema['params'] ? ResolvePath<Path> : Schema['params'];
            query: Schema['query'];
            response: ComposeSpiceflowResponse<Schema['response'], Handle>;
        };
    }>, RoutePaths | JoinPath<BasePath, Path>>;
    route<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends UnwrapRoute<LocalSchema, Definitions['type']>, const Handle extends InlineHandler<this, Schema, Singleton, JoinPath<BasePath, Path>>, Method extends HTTPMethod | HTTPMethod[] = '*'>(options: LocalHook<LocalSchema, Schema, Singleton, Definitions['error'], Metadata['macro'], JoinPath<BasePath, Path>> & {
        path: Path;
        method?: Method;
        handler: Handle;
    }): Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, ClientRoutes & CreateClient<JoinPath<BasePath, Path>, {
        [M in Method extends readonly (infer E)[] ? Lowercase<E & string> : Lowercase<Method & string>]: {
            request: GetRequestSchema<Schema>;
            params: undefined extends Schema['params'] ? ResolvePath<Path> : Schema['params'];
            query: Schema['query'];
            response: ComposeSpiceflowResponse<Schema['response'], Handle>;
        };
    }>, RoutePaths | JoinPath<BasePath, Path>>;
    patch<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends UnwrapRoute<LocalSchema, Definitions['type']>, const Handle extends InlineHandler<this, Schema, Singleton, JoinPath<BasePath, Path>>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton, Definitions['error'], Metadata['macro'], JoinPath<BasePath, Path>>): Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, ClientRoutes & CreateClient<JoinPath<BasePath, Path>, {
        patch: {
            request: GetRequestSchema<Schema>;
            params: undefined extends Schema['params'] ? ResolvePath<Path> : Schema['params'];
            query: Schema['query'];
            response: ComposeSpiceflowResponse<Schema['response'], Handle>;
        };
    }>, RoutePaths | JoinPath<BasePath, Path>>;
    delete<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends UnwrapRoute<LocalSchema, Definitions['type']>, const Handle extends InlineHandler<this, Schema, Singleton, JoinPath<BasePath, Path>>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton, Definitions['error'], Metadata['macro'], JoinPath<BasePath, Path>>): Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, ClientRoutes & CreateClient<JoinPath<BasePath, Path>, {
        delete: {
            request: GetRequestSchema<Schema>;
            params: undefined extends Schema['params'] ? ResolvePath<Path> : Schema['params'];
            query: Schema['query'];
            response: ComposeSpiceflowResponse<Schema['response'], Handle>;
        };
    }>, RoutePaths | JoinPath<BasePath, Path>>;
    options<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends UnwrapRoute<LocalSchema, Definitions['type']>, const Handle extends InlineHandler<this, Schema, Singleton, JoinPath<BasePath, Path>>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton, Definitions['error'], Metadata['macro'], JoinPath<BasePath, Path>>): Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, ClientRoutes & CreateClient<JoinPath<BasePath, Path>, {
        options: {
            request: GetRequestSchema<Schema>;
            params: undefined extends Schema['params'] ? ResolvePath<Path> : Schema['params'];
            query: Schema['query'];
            response: ComposeSpiceflowResponse<Schema['response'], Handle>;
        };
    }>, RoutePaths | JoinPath<BasePath, Path>>;
    all<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends UnwrapRoute<LocalSchema, Definitions['type']>, const Handle extends InlineHandler<this, Schema, Singleton, JoinPath<BasePath, Path>>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton, Definitions['error'], Metadata['macro'], JoinPath<BasePath, Path>>): Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, ClientRoutes & CreateClient<JoinPath<BasePath, Path>, {
        [method in string]: {
            request: GetRequestSchema<Schema>;
            params: undefined extends Schema['params'] ? ResolvePath<Path> : Schema['params'];
            query: Schema['query'];
            response: ComposeSpiceflowResponse<Schema['response'], Handle>;
        };
    }>, RoutePaths | JoinPath<BasePath, Path>>;
    head<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends UnwrapRoute<LocalSchema, Definitions['type']>, const Handle extends InlineHandler<this, Schema, Singleton, JoinPath<BasePath, Path>>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton, Definitions['error'], Metadata['macro'], JoinPath<BasePath, Path>>): Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, ClientRoutes & CreateClient<JoinPath<BasePath, Path>, {
        head: {
            request: GetRequestSchema<Schema>;
            params: undefined extends Schema['params'] ? ResolvePath<Path> : Schema['params'];
            query: Schema['query'];
            response: ComposeSpiceflowResponse<Schema['response'], Handle>;
        };
    }>, RoutePaths | JoinPath<BasePath, Path>>;
    private scoped?;
    use<const NewSpiceflow extends AnySpiceflow>(instance: NewSpiceflow): IsAny<NewSpiceflow> extends true ? this : Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, BasePath extends `` ? ClientRoutes & NewSpiceflow['_types']['ClientRoutes'] : ClientRoutes & CreateClient<BasePath, NewSpiceflow['_types']['ClientRoutes']>, RoutePaths | NewSpiceflow['_types']['RoutePaths']>;
    use<const Schema extends RouteSchema>(handler: MiddlewareHandler<Schema, Singleton>): this;
    onError<const Schema extends RouteSchema>(handler: ErrorHandler<Definitions['error'], Schema, Singleton>): this;
    handle: (request: Request, { state: customState }?: {
        state?: Singleton["state"];
    }) => Promise<Response>;
    protected superjsonSerialize(value: any, indent?: boolean, request?: Request): string;
    private turnHandlerResultIntoResponse;
    private runErrorHandlers;
    private joinBasePaths;
    private getAppAndParents;
    private getAppsInScope;
    listen(port: number, hostname?: string): Promise<{
        port: number;
        server: import("http").Server<typeof IncomingMessage, typeof ServerResponse>;
    } | {
        port: number | undefined;
        server: Bun.Server;
    }>;
    /**
     * @deprecated Use `handleForNode` instead.
     */
    handleNode(req: IncomingMessage, res: ServerResponse, context?: {
        state?: Singleton['state'];
    }): Promise<void>;
    handleForNode: (req: IncomingMessage, res: ServerResponse, context?: {
        state?: Singleton["state"];
    }) => Promise<void>;
    listenForNode(port: number, hostname?: string): Promise<{
        port: number;
        server: import("http").Server<typeof IncomingMessage, typeof ServerResponse>;
    }>;
    private handleStream;
    safePath<const Path extends RoutePaths, const Params extends ExtractParamsFromPath<Path>>(path: Path, ...rest: [Params] extends [undefined] ? [] | [params?: Params] : [params: Params]): string;
}
declare const METHODS: readonly ["ALL", "CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
/** HTTP method string */
export type Method = (typeof METHODS)[number];
export declare class SpiceflowRequest<T = any> extends Request {
    validateBody?: ValidationFunction;
    json(): Promise<T>;
}
export declare function bfs(tree: AnySpiceflow): AnySpiceflow[];
export type AnySpiceflow = Spiceflow<any, any, any, any, any, any, any>;
export declare function isZodSchema(value: unknown): value is ZodType;
import type * as z4 from 'zod/v4/core';
/** `true` ⇒ the value was created by Zod 4, `false` ⇒ Zod 3 */
export declare function isZod4(schema: any): schema is z4.$ZodObject;
export declare function cloneDeep(x: any): any;
export {};
//# sourceMappingURL=spiceflow.d.ts.map