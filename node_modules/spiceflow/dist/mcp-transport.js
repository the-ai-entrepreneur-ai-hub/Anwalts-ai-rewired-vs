import { JSONRPCMessageSchema, } from '@modelcontextprotocol/sdk/types.js';
/**
 * Server transport for SSE: this will send messages over an SSE connection and receive messages from HTTP POST requests.
 *
 * This transport is only available in Node.js environments.
 */
export class SSEServerTransportSpiceflow {
    _sessionId;
    _endpoint;
    _writableStream;
    response;
    onclose;
    onerror;
    onmessage;
    /**
     * Creates a new SSE server transport, which will direct the client to POST messages to the relative or absolute URL identified by `_endpoint`.
     */
    constructor(endpoint) {
        this._sessionId = crypto.randomUUID();
        this._endpoint = endpoint;
    }
    /**
     * Handles the initial SSE connection request.
     *
     * This should be called when a GET request is made to establish the SSE stream.
     */
    async start() {
        if (this.response) {
            throw new Error('SSEServerTransport already started! If using Server class, note that connect() calls start() automatically.');
        }
        const headers = new Headers({
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            // https://github.com/vercel/next.js/issues/9965
            'content-encoding': 'none',
            Connection: 'keep-alive',
        });
        // Create a TransformStream
        const transformStream = new TransformStream();
        const { readable, writable } = transformStream;
        // Create the Response from the readable side
        this.response = new Response(readable, { headers });
        // Obtain a writer from the writable end
        this._writableStream = writable.getWriter();
        this._writableStream?.write(new TextEncoder().encode(`event: endpoint\ndata: ${encodeURI(this._endpoint)}?sessionId=${this._sessionId}\n\n`));
    }
    /**
     * Handles incoming POST messages.
     *
     * This should be called when a POST request is made to send a message to the server.
     */
    async handlePostMessage(req) {
        if (!this.response) {
            const message = 'SSE connection not established';
            throw new Error(message);
        }
        let body = await req.json();
        try {
            await this.handleMessage(typeof body === 'string' ? JSON.parse(body) : body);
        }
        catch {
            return new Response(`Invalid message: ${body}`, { status: 400 });
        }
        return new Response('Accepted', { status: 202 });
    }
    /**
     * Handle a client message, regardless of how it arrived. This can be used to inform the server of messages that arrive via a means different than HTTP POST.
     */
    async handleMessage(message) {
        let parsedMessage;
        try {
            parsedMessage = JSONRPCMessageSchema.parse(message);
        }
        catch (error) {
            this.onerror?.(error);
            throw error;
        }
        this.onmessage?.(parsedMessage);
    }
    async close() {
        if (this._writableStream) {
            await this._writableStream.close();
        }
        this.response = undefined;
        this._writableStream = undefined;
        this.onclose?.();
    }
    async send(message) {
        if (!this._writableStream) {
            throw new Error('Not connected');
        }
        const encoder = new TextEncoder();
        const data = encoder.encode(`event: message\ndata: ${JSON.stringify(message)}\n\n`);
        await this._writableStream.write(data);
    }
    /**
     * Returns the session ID for this transport.
     *
     * This can be used to route incoming POST requests.
     */
    get sessionId() {
        return this._sessionId;
    }
}
//# sourceMappingURL=mcp-transport.js.map