import { JSONRPCMessageSchema, } from '@modelcontextprotocol/sdk/types.js';
import { streamSSEResponse } from "./client/index.js";
export class FetchMCPCLientTransport {
    _endpoint;
    sseUrl;
    _abortController;
    fetch;
    onmessage;
    onerror = (e) => {
        throw e;
    };
    onclose;
    constructor(opts) {
        this.fetch = opts.fetch || fetch;
        this.sseUrl = new URL(opts.url);
        this._abortController = new AbortController();
    }
    onEndpointMessage = () => { };
    async start() {
        const { promise, resolve, reject } = withResolvers();
        this.consumeEvents().catch((e) => {
            reject(e);
        });
        this.onEndpointMessage = (endpoint) => {
            this._endpoint = endpoint;
            resolve(endpoint);
        };
        await promise;
        this.log(`finished start`);
    }
    log(...x) {
        // console.log(...x)
        //
    }
    async consumeEvents() {
        const sseRes = await this.fetch(new Request(this.sseUrl.toString(), {
            method: 'GET',
            signal: this._abortController.signal,
            headers: {
                ...(await this._commonHeaders()),
                accept: 'text/event-stream',
            },
        }));
        if (!sseRes.ok || !sseRes.body) {
            const text = sseRes.body ? await sseRes.text().catch(() => '') : '';
            throw new Error(`SSE connection failed (HTTP ${sseRes.status})\nURL: ${this.sseUrl}\nText: ${text}`);
        }
        for await (const evt of streamSSEResponse(sseRes, (x) => {
            return x;
        })) {
            if (evt.event === 'endpoint') {
                const url = new URL(evt.data, this.sseUrl);
                if (url.origin !== this.sseUrl.origin) {
                    throw new Error(`Endpoint origin mismatch: ${url.origin}`);
                }
                this.onEndpointMessage(url);
                this._endpoint = url;
            }
            else if (evt.event === 'message') {
                // JSON-RPC payload
                try {
                    const msg = JSONRPCMessageSchema.parse(JSON.parse(evt.data));
                    this.log(msg);
                    this.onmessage?.(msg);
                }
                catch (err) {
                    this.onerror?.(err);
                }
            }
            else {
                this.log('Unknown MCP event:', evt);
            }
        }
        this.close?.();
    }
    catch(err) {
        this.onerror?.(err);
    }
    async _commonHeaders() {
        const headers = {};
        // if (this._authProvider) {
        //   const tokens = await this._authProvider.tokens()
        //   if (tokens) {
        //     headers['Authorization'] = `Bearer ${tokens.access_token}`
        //   }
        // }
        if (this._protocolVersion) {
            headers['mcp-protocol-version'] = this._protocolVersion;
        }
        return headers;
    }
    /**
     * Sends a JSON-RPC message by POSTing to the negotiated endpoint.
     * Must call start() first so that endpoint is set.
     */
    async send(message) {
        if (!this._endpoint) {
            throw new Error('Not connected');
        }
        this.log(`sending`, message);
        const res = await this.fetch(new Request(this._endpoint.toString(), {
            method: 'POST',
            headers: {
                ...(await this._commonHeaders()),
                'content-type': 'application/json',
            },
            body: JSON.stringify(message),
            signal: this._abortController?.signal,
        }));
        if (!res.ok) {
            const text = await res.text().catch(() => '');
            const err = new Error(`Error POSTing to endpoint ${this._endpoint || '.'} (HTTP ${res.status}): ${text}`);
            this.onerror?.(err);
            throw err;
        }
    }
    /**
     * Aborts the SSE stream and notifies onclose.
     */
    async close() {
        this._abortController?.abort();
        this.onclose?.();
    }
    _protocolVersion;
    setProtocolVersion(version) {
        this._protocolVersion = version;
    }
}
/**
 * Polyfill for Promise.withResolvers
 * Returns an object { promise, resolve, reject }
 * If native Promise.withResolvers exists, uses it.
 */
function withResolvers() {
    if (typeof Promise.withResolvers === 'function') {
        return Promise.withResolvers();
    }
    let resolve;
    let reject;
    const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
    });
    // @ts-ignore checked by closure above
    return { promise, resolve, reject };
}
//# sourceMappingURL=mcp-client-transport.js.map