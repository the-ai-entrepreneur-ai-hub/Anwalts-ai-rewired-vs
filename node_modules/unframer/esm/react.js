'use client';
import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { combinedCSSRules } from './framer.js';
import { preconnect, prefetchDNS } from 'react-dom';
import { createContext, useContext, useMemo, useSyncExternalStore, } from 'react';
import { breakpointsStylesLegacy, defaultBreakpointSizes, getFontsStyles, } from './css.js';
import { version } from './version.js';
function classNames(...args) {
    return args.filter(Boolean).join(' ');
}
function Hints() {
    prefetchDNS('https://fonts.gstatic.com');
    preconnect('https://fonts.gstatic.com');
    preconnect('https://framerusercontent.com');
    return null; // nothing to render
}
// breakpoints from the higher to the lower
const defaultBreakpoints = Object.keys(defaultBreakpointSizes).reverse();
function getBreakpointNameFromWindowWidth(windowWidth) {
    return defaultBreakpoints.find((name) => windowWidth >= defaultBreakpointSizes[name]);
}
function fillBreakpoints(breakpoints) {
    const breakpointsOrder = ['base', 'sm', 'md', 'lg', 'xl', '2xl'];
    const filledBreakpoints = { ...breakpoints };
    for (let i = 1; i < breakpointsOrder.length; i++) {
        const currentBreakpoint = breakpointsOrder[i];
        const previousBreakpoint = breakpointsOrder[i - 1];
        if (!filledBreakpoints[currentBreakpoint]) {
            filledBreakpoints[currentBreakpoint] =
                filledBreakpoints[previousBreakpoint];
        }
    }
    return filledBreakpoints;
}
const nothing = () => {
    return () => { };
};
/**
 * @deprecated Use styles.css import instead
 */
export function FramerStyles({ Components = [] }) {
    const isClient = useSyncExternalStore(nothing, () => true, () => false);
    const breakpoints = (_jsx("style", { dangerouslySetInnerHTML: {
            __html: breakpointsStylesLegacy(defaultBreakpointSizes),
        }, suppressHydrationWarning: true, hidden: true }, 'breakpointsStyles'));
    const fonts = (_jsx("style", { dangerouslySetInnerHTML: {
            __html: getFontsStyles(Components.map((x) => x.fonts || []).flat()),
        }, suppressHydrationWarning: true, hidden: true }, 'fonts'));
    // if (isClient) {
    //     // on client framer injects the styles by itself
    //     return (
    //         <>
    //             {breakpoints}
    //             {fonts}
    //         </>
    //     )
    // }
    return (_jsxs(_Fragment, { children: [breakpoints, fonts, _jsx("style", { dangerouslySetInnerHTML: {
                    __html: combinedCSSRules.join('\n'),
                }, suppressHydrationWarning: true, hidden: true }, 'combinedCSSRules')] }));
}
function removeInactiveUnframerHiddenElements() {
    // Remove all elements with the 'unframer-hidden' class that are not for the current breakpoint
    const windowWidth = window.innerWidth;
    const activeBreakpoint = getBreakpointNameFromWindowWidth(windowWidth);
    const activeClass = activeBreakpoint ? `unframer-${activeBreakpoint}` : null;
    console.log('Active unframer breakpoint class:', activeClass);
    document.querySelectorAll('.unframer-hidden').forEach((el) => {
        // Merge: Only remove the element itself if it has 'unframer-hidden' and does not match the current breakpoint's class.
        if (el.classList.contains('unframer-hidden') &&
            activeClass &&
            !el.classList.contains(activeClass)) {
            el.parentNode?.removeChild(el);
        }
    });
}
if (typeof window !== 'undefined') {
    removeInactiveUnframerHiddenElements();
}
export const WithFramerBreakpoints = ({ Component, variants: _breakpointsMap, ...rest }) => {
    const currentBreakpoint = useSyncExternalStore(onResize, () => {
        // console.log('window.innerWidth', window.innerWidth)
        const breakpoint = getBreakpointNameFromWindowWidth(window.innerWidth);
        return breakpoint;
    }, () => {
        if (typeof window !== 'undefined') {
            const breakpoint = getBreakpointNameFromWindowWidth(window.innerWidth);
            return breakpoint;
        }
        return '';
    });
    if (isEmpty(_breakpointsMap)) {
        // @ts-ignore
        return _jsx(Component, { ...rest });
    }
    const allBreakpoints = fillBreakpoints(_breakpointsMap);
    const variants = new Map();
    for (let breakpointName of Object.keys(allBreakpoints)) {
        const realVariant = allBreakpoints[breakpointName];
        if (!realVariant) {
            continue;
        }
        const existingVariant = variants.get(realVariant);
        if (existingVariant) {
            existingVariant.breakpoints.push(breakpointName);
            existingVariant.className = classNames(existingVariant.className, `unframer-${breakpointName}`);
        }
        else {
            variants.set(realVariant, {
                className: classNames('unframer unframer-hidden', `unframer-${breakpointName}`),
                variant: realVariant,
                breakpoints: [breakpointName],
            });
        }
    }
    const parts = [...variants.values()].map(({ className, breakpoints, variant }, i) => {
        const shouldShow = !currentBreakpoint || breakpoints.includes(currentBreakpoint);
        if (!shouldShow) {
            return null;
        }
        const c = classNames(className, rest.className);
        return (
        // @ts-ignore
        _jsx(Component, { suppressHydrationWarning: true, 
            // LayoutGroup is used internally
            layoutId: variant, ...rest, className: c, variant: variant }, variant));
    });
    parts.push(_jsx(DebugUnframerVersion, {}, 'debug-unframer-version'));
    return parts;
};
const onResize = (callback) => {
    window.addEventListener('resize', callback);
    return () => window.removeEventListener('resize', callback);
};
const onResizeWithDebounce = (callback) => {
    let timeoutId;
    const debouncedCallback = () => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            callback();
        }, 16);
    };
    window.addEventListener('resize', debouncedCallback);
    return () => {
        clearTimeout(timeoutId);
        window.removeEventListener('resize', debouncedCallback);
    };
};
import React from 'react';
import { 
// @ts-ignore
CustomCursorHost, 
// @ts-ignore
FetchClientProvider, 
// @ts-ignore
FormContext, 
// @ts-ignore
FramerLink as Link, 
// @ts-ignore
LocaleInfoContext, } from './framer.js';
const routesContext = React.createContext({});
function replacePathParams(path, params) {
    const paramRegex = /:[a-zA-Z]+/g;
    const matches = path.match(paramRegex);
    // If there is only one match
    if (matches?.length === 1) {
        const paramValue = Object.values(params)[0];
        let res = path.replace(paramRegex, paramValue);
        // console.log({ matches, params, paramValue, res })
        return res;
    }
    return path.replace(paramRegex, (match) => {
        const param = match.slice(1); // Remove the : prefix
        return params[param] || match; // Replace with param value or keep original if not found
    });
}
export function ResolveLinksAdapted({ links, children }) {
    // TODO add ref
    return children(links.map((x) => x.href));
}
function isRelativeLink(url) {
    if (!url) {
        return false;
    }
    return url?.startsWith?.('/') || url?.startsWith?.('#');
}
function isMailto(url) {
    if (!url) {
        return false;
    }
    return url?.startsWith?.('mailto:');
}
export function AdaptedLink({ href, nodeId, openInNewTab, smoothScroll, children, ...rest }) {
    const context = useContext(unframerContext);
    let navigateClientSide = context.navigate && !openInNewTab
        ? (e) => {
            if (!context.navigate)
                return;
            const href = e.currentTarget?.getAttribute('href');
            if (!href || !isRelativeLink(href))
                return;
            e.preventDefault();
            if (rest.onClick)
                rest.onClick(e);
            context.navigate(href);
        }
        : null;
    const onlyForFramer = { children, nodeId, openInNewTab, smoothScroll };
    const routes = React.useContext(routesContext);
    const webPageId = href?.webPageId;
    const pathVariables = href?.pathVariables;
    const route = routes?.[webPageId];
    const target = openInNewTab ? '_blank' : undefined;
    if (isRelativeLink(href) || isMailto(href)) {
        return (_jsx(_Fragment, { children: React.cloneElement(children, {
                ...rest,
                suppressHydrationWarning: true,
                onClick: navigateClientSide,
                href,
                target,
            }) }));
    }
    if (!webPageId) {
        return (_jsx(Link, { suppressHydrationWarning: true, href: href, ...rest, ...onlyForFramer }));
    }
    if (!route || !route.path) {
        return (_jsx(Link, { suppressHydrationWarning: true, href: href, ...rest, ...onlyForFramer }));
    }
    let resolvedPath = route.path;
    if (pathVariables) {
        resolvedPath = replacePathParams(resolvedPath, pathVariables);
    }
    if (isRelativeLink(resolvedPath) || isMailto(href)) {
        return (_jsx(_Fragment, { children: React.cloneElement(children, {
                ...rest,
                suppressHydrationWarning: true,
                onClick: navigateClientSide,
                href: resolvedPath,
                target,
            }) }));
    }
    return (_jsx(Link, { href: resolvedPath, suppressHydrationWarning: true, ...rest, ...onlyForFramer }));
}
export function ContextProviders({ locale: locale_, children, framerSiteId, routes, 
// collectionUtils,
locales, }) {
    const context = useContext(unframerContext);
    const locale = locale_ || context?.locale;
    const activeLocale = locales?.find((l) => l.slug === locale || l.code === locale || l.id === locale);
    const localeInfo = useMemo(() => {
        return {
            activeLocale,
            locales,
            setLocale: async (localeOrLocaleId) => {
                console.log('setLocale', localeOrLocaleId);
            },
        };
    }, [activeLocale, locales]);
    return (_jsxs(FetchClientProvider, { children: [_jsx(Hints, {}), _jsx(CustomCursorHost, { children: _jsx(FormContext.Provider, { value: framerSiteId, children: _jsx(LocaleInfoContext, { value: localeInfo, children: _jsx(routesContext.Provider, { value: routes, children: children }) }) }) })] }));
}
/**
 * Add Unframer debug information to debug websites using Unframer
 */
function DebugUnframerVersion() {
    return (_jsxs("details", { style: { display: 'none' }, children: ["Using", ' ', _jsx("a", { href: 'https://unframer.co', className: '', children: "Framer React Export" }), ' ', "version ", version] }));
}
function isEmpty(obj) {
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            return false;
        }
    }
    return true;
}
const unframerContext = createContext({
    navigate: undefined,
});
export function UnframerProvider(props) {
    return (_jsxs(unframerContext.Provider, { value: props, children: [_jsx(Hints, {}), props.children] }));
}
//# sourceMappingURL=react.js.map