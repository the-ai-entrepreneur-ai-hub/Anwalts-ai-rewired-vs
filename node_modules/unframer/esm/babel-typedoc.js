function toBlockComment(value) {
    // Ensure we only keep the contents between /** and */
    const cleaned = value
        .trim()
        // drop beginning "/**" (with optional extra *) and any leading whitespace
        .replace(/^\/\*\*+/, '')
        // drop ending "*/"
        .replace(/\*\/$/, '');
    // We deliberately keep the leading '*' characters in each line so Babel
    // prints "/** … */" instead of "/* … */".
    // Add a leading asterisk if none exists to ensure JSDoc-style comments
    const withLeadingAsterisk = cleaned.startsWith('*') ? cleaned : '*' + cleaned;
    return {
        type: 'CommentBlock',
        value: withLeadingAsterisk,
    };
}
export function babelPluginTypedoc(options) {
    return function ({ types: t }) {
        const { headerComment, responsiveComment, defaultExportComment, } = options;
        return {
            name: 'inject-typedoc-comments',
            visitor: {
                Program: {
                    enter(path) {
                        if (!headerComment)
                            return;
                        const comment = toBlockComment(headerComment);
                        const body = path.node.body;
                        // Find the first non-directive statement. Directives are
                        // ExpressionStatements whose expression is a
                        // StringLiteral and which are placed at the top.
                        const firstNonDirective = body.find((stmt) => !(t.isExpressionStatement(stmt) &&
                            t.isStringLiteral(stmt.expression)));
                        if (firstNonDirective) {
                            firstNonDirective.leadingComments = (firstNonDirective.leadingComments || []).concat(comment);
                        }
                        else if (body.length) {
                            // Fallback – attach to the very first node
                            body[0].leadingComments = (body[0].leadingComments || []).concat(comment);
                        }
                        else {
                            // Empty file (unlikely) – create an empty statement
                            const empty = t.emptyStatement();
                            empty.leadingComments = [comment];
                            body.push(empty);
                        }
                    },
                },
                ExpressionStatement(path) {
                    if (!responsiveComment)
                        return;
                    const expr = path.node.expression;
                    if (t.isAssignmentExpression(expr) &&
                        t.isMemberExpression(expr.left) &&
                        !expr.left.computed &&
                        t.isIdentifier(expr.left.property) &&
                        expr.left.property.name === 'Responsive') {
                        path.node.leadingComments = (path.node.leadingComments || []).concat(toBlockComment(responsiveComment));
                    }
                },
                FunctionDeclaration(path) {
                    if (!defaultExportComment)
                        return;
                    // Look for ComponentWithRoot function declaration
                    if (path.node.id?.name === 'ComponentWithRoot') {
                        path.node.leadingComments = (path.node.leadingComments || []).concat(toBlockComment(defaultExportComment));
                    }
                },
            },
        };
    };
}
//# sourceMappingURL=babel-typedoc.js.map