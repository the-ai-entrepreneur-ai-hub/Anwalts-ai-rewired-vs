'use client';
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WithFramerBreakpoints = void 0;
exports.FramerStyles = FramerStyles;
exports.ResolveLinksAdapted = ResolveLinksAdapted;
exports.AdaptedLink = AdaptedLink;
exports.ContextProviders = ContextProviders;
exports.UnframerProvider = UnframerProvider;
const jsx_runtime_1 = require("react/jsx-runtime");
const framer_js_1 = require("./framer.js");
const react_dom_1 = require("react-dom");
const react_1 = require("react");
const css_js_1 = require("./css.js");
const version_js_1 = require("./version.js");
function classNames(...args) {
    return args.filter(Boolean).join(' ');
}
function Hints() {
    (0, react_dom_1.prefetchDNS)('https://fonts.gstatic.com');
    (0, react_dom_1.preconnect)('https://fonts.gstatic.com');
    (0, react_dom_1.preconnect)('https://framerusercontent.com');
    return null; // nothing to render
}
// breakpoints from the higher to the lower
const defaultBreakpoints = Object.keys(css_js_1.defaultBreakpointSizes).reverse();
function getBreakpointNameFromWindowWidth(windowWidth) {
    return defaultBreakpoints.find((name) => windowWidth >= css_js_1.defaultBreakpointSizes[name]);
}
function fillBreakpoints(breakpoints) {
    const breakpointsOrder = ['base', 'sm', 'md', 'lg', 'xl', '2xl'];
    const filledBreakpoints = { ...breakpoints };
    for (let i = 1; i < breakpointsOrder.length; i++) {
        const currentBreakpoint = breakpointsOrder[i];
        const previousBreakpoint = breakpointsOrder[i - 1];
        if (!filledBreakpoints[currentBreakpoint]) {
            filledBreakpoints[currentBreakpoint] =
                filledBreakpoints[previousBreakpoint];
        }
    }
    return filledBreakpoints;
}
const nothing = () => {
    return () => { };
};
/**
 * @deprecated Use styles.css import instead
 */
function FramerStyles({ Components = [] }) {
    const isClient = (0, react_1.useSyncExternalStore)(nothing, () => true, () => false);
    const breakpoints = ((0, jsx_runtime_1.jsx)("style", { dangerouslySetInnerHTML: {
            __html: (0, css_js_1.breakpointsStylesLegacy)(css_js_1.defaultBreakpointSizes),
        }, suppressHydrationWarning: true, hidden: true }, 'breakpointsStyles'));
    const fonts = ((0, jsx_runtime_1.jsx)("style", { dangerouslySetInnerHTML: {
            __html: (0, css_js_1.getFontsStyles)(Components.map((x) => x.fonts || []).flat()),
        }, suppressHydrationWarning: true, hidden: true }, 'fonts'));
    // if (isClient) {
    //     // on client framer injects the styles by itself
    //     return (
    //         <>
    //             {breakpoints}
    //             {fonts}
    //         </>
    //     )
    // }
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [breakpoints, fonts, (0, jsx_runtime_1.jsx)("style", { dangerouslySetInnerHTML: {
                    __html: framer_js_1.combinedCSSRules.join('\n'),
                }, suppressHydrationWarning: true, hidden: true }, 'combinedCSSRules')] }));
}
function removeInactiveUnframerHiddenElements() {
    // Remove all elements with the 'unframer-hidden' class that are not for the current breakpoint
    const windowWidth = window.innerWidth;
    const activeBreakpoint = getBreakpointNameFromWindowWidth(windowWidth);
    const activeClass = activeBreakpoint ? `unframer-${activeBreakpoint}` : null;
    console.log('Active unframer breakpoint class:', activeClass);
    document.querySelectorAll('.unframer-hidden').forEach((el) => {
        // Merge: Only remove the element itself if it has 'unframer-hidden' and does not match the current breakpoint's class.
        if (el.classList.contains('unframer-hidden') &&
            activeClass &&
            !el.classList.contains(activeClass)) {
            el.parentNode?.removeChild(el);
        }
    });
}
if (typeof window !== 'undefined') {
    removeInactiveUnframerHiddenElements();
}
const WithFramerBreakpoints = ({ Component, variants: _breakpointsMap, ...rest }) => {
    const currentBreakpoint = (0, react_1.useSyncExternalStore)(onResize, () => {
        // console.log('window.innerWidth', window.innerWidth)
        const breakpoint = getBreakpointNameFromWindowWidth(window.innerWidth);
        return breakpoint;
    }, () => {
        if (typeof window !== 'undefined') {
            const breakpoint = getBreakpointNameFromWindowWidth(window.innerWidth);
            return breakpoint;
        }
        return '';
    });
    if (isEmpty(_breakpointsMap)) {
        // @ts-ignore
        return (0, jsx_runtime_1.jsx)(Component, { ...rest });
    }
    const allBreakpoints = fillBreakpoints(_breakpointsMap);
    const variants = new Map();
    for (let breakpointName of Object.keys(allBreakpoints)) {
        const realVariant = allBreakpoints[breakpointName];
        if (!realVariant) {
            continue;
        }
        const existingVariant = variants.get(realVariant);
        if (existingVariant) {
            existingVariant.breakpoints.push(breakpointName);
            existingVariant.className = classNames(existingVariant.className, `unframer-${breakpointName}`);
        }
        else {
            variants.set(realVariant, {
                className: classNames('unframer unframer-hidden', `unframer-${breakpointName}`),
                variant: realVariant,
                breakpoints: [breakpointName],
            });
        }
    }
    const parts = [...variants.values()].map(({ className, breakpoints, variant }, i) => {
        const shouldShow = !currentBreakpoint || breakpoints.includes(currentBreakpoint);
        if (!shouldShow) {
            return null;
        }
        const c = classNames(className, rest.className);
        return (
        // @ts-ignore
        (0, jsx_runtime_1.jsx)(Component, { suppressHydrationWarning: true, 
            // LayoutGroup is used internally
            layoutId: variant, ...rest, className: c, variant: variant }, variant));
    });
    parts.push((0, jsx_runtime_1.jsx)(DebugUnframerVersion, {}, 'debug-unframer-version'));
    return parts;
};
exports.WithFramerBreakpoints = WithFramerBreakpoints;
const onResize = (callback) => {
    window.addEventListener('resize', callback);
    return () => window.removeEventListener('resize', callback);
};
const onResizeWithDebounce = (callback) => {
    let timeoutId;
    const debouncedCallback = () => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            callback();
        }, 16);
    };
    window.addEventListener('resize', debouncedCallback);
    return () => {
        clearTimeout(timeoutId);
        window.removeEventListener('resize', debouncedCallback);
    };
};
const react_2 = __importDefault(require("react"));
const framer_js_2 = require("./framer.js");
const routesContext = react_2.default.createContext({});
function replacePathParams(path, params) {
    const paramRegex = /:[a-zA-Z]+/g;
    const matches = path.match(paramRegex);
    // If there is only one match
    if (matches?.length === 1) {
        const paramValue = Object.values(params)[0];
        let res = path.replace(paramRegex, paramValue);
        // console.log({ matches, params, paramValue, res })
        return res;
    }
    return path.replace(paramRegex, (match) => {
        const param = match.slice(1); // Remove the : prefix
        return params[param] || match; // Replace with param value or keep original if not found
    });
}
function ResolveLinksAdapted({ links, children }) {
    // TODO add ref
    return children(links.map((x) => x.href));
}
function isRelativeLink(url) {
    if (!url) {
        return false;
    }
    return url?.startsWith?.('/') || url?.startsWith?.('#');
}
function isMailto(url) {
    if (!url) {
        return false;
    }
    return url?.startsWith?.('mailto:');
}
function AdaptedLink({ href, nodeId, openInNewTab, smoothScroll, children, ...rest }) {
    const context = (0, react_1.useContext)(unframerContext);
    let navigateClientSide = context.navigate && !openInNewTab
        ? (e) => {
            if (!context.navigate)
                return;
            const href = e.currentTarget?.getAttribute('href');
            if (!href || !isRelativeLink(href))
                return;
            e.preventDefault();
            if (rest.onClick)
                rest.onClick(e);
            context.navigate(href);
        }
        : null;
    const onlyForFramer = { children, nodeId, openInNewTab, smoothScroll };
    const routes = react_2.default.useContext(routesContext);
    const webPageId = href?.webPageId;
    const pathVariables = href?.pathVariables;
    const route = routes?.[webPageId];
    const target = openInNewTab ? '_blank' : undefined;
    if (isRelativeLink(href) || isMailto(href)) {
        return ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: react_2.default.cloneElement(children, {
                ...rest,
                suppressHydrationWarning: true,
                onClick: navigateClientSide,
                href,
                target,
            }) }));
    }
    if (!webPageId) {
        return ((0, jsx_runtime_1.jsx)(framer_js_2.FramerLink, { suppressHydrationWarning: true, href: href, ...rest, ...onlyForFramer }));
    }
    if (!route || !route.path) {
        return ((0, jsx_runtime_1.jsx)(framer_js_2.FramerLink, { suppressHydrationWarning: true, href: href, ...rest, ...onlyForFramer }));
    }
    let resolvedPath = route.path;
    if (pathVariables) {
        resolvedPath = replacePathParams(resolvedPath, pathVariables);
    }
    if (isRelativeLink(resolvedPath) || isMailto(href)) {
        return ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: react_2.default.cloneElement(children, {
                ...rest,
                suppressHydrationWarning: true,
                onClick: navigateClientSide,
                href: resolvedPath,
                target,
            }) }));
    }
    return ((0, jsx_runtime_1.jsx)(framer_js_2.FramerLink, { href: resolvedPath, suppressHydrationWarning: true, ...rest, ...onlyForFramer }));
}
function ContextProviders({ locale: locale_, children, framerSiteId, routes, 
// collectionUtils,
locales, }) {
    const context = (0, react_1.useContext)(unframerContext);
    const locale = locale_ || context?.locale;
    const activeLocale = locales?.find((l) => l.slug === locale || l.code === locale || l.id === locale);
    const localeInfo = (0, react_1.useMemo)(() => {
        return {
            activeLocale,
            locales,
            setLocale: async (localeOrLocaleId) => {
                console.log('setLocale', localeOrLocaleId);
            },
        };
    }, [activeLocale, locales]);
    return ((0, jsx_runtime_1.jsxs)(framer_js_2.FetchClientProvider, { children: [(0, jsx_runtime_1.jsx)(Hints, {}), (0, jsx_runtime_1.jsx)(framer_js_2.CustomCursorHost, { children: (0, jsx_runtime_1.jsx)(framer_js_2.FormContext.Provider, { value: framerSiteId, children: (0, jsx_runtime_1.jsx)(framer_js_2.LocaleInfoContext, { value: localeInfo, children: (0, jsx_runtime_1.jsx)(routesContext.Provider, { value: routes, children: children }) }) }) })] }));
}
/**
 * Add Unframer debug information to debug websites using Unframer
 */
function DebugUnframerVersion() {
    return ((0, jsx_runtime_1.jsxs)("details", { style: { display: 'none' }, children: ["Using", ' ', (0, jsx_runtime_1.jsx)("a", { href: 'https://unframer.co', className: '', children: "Framer React Export" }), ' ', "version ", version_js_1.version] }));
}
function isEmpty(obj) {
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            return false;
        }
    }
    return true;
}
const unframerContext = (0, react_1.createContext)({
    navigate: undefined,
});
function UnframerProvider(props) {
    return ((0, jsx_runtime_1.jsxs)(unframerContext.Provider, { value: props, children: [(0, jsx_runtime_1.jsx)(Hints, {}), props.children] }));
}
//# sourceMappingURL=react.js.map