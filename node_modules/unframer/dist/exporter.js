"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bundle = bundle;
exports.resolvePackageVersion = resolvePackageVersion;
exports.resolvePackage = resolvePackage;
exports.getDarkModeSelector = getDarkModeSelector;
exports.getStyleTokensCss = getStyleTokensCss;
exports.findRelativeLinks = findRelativeLinks;
exports.extractPropControlsUnsafe = extractPropControlsUnsafe;
exports.parsePropertyControls = parsePropertyControls;
exports.extractTokenInfo = extractTokenInfo;
exports.indentWithTabs = indentWithTabs;
exports.createExampleComponentCode = createExampleComponentCode;
exports.isVersionGreater = isVersionGreater;
const esbuild_1 = require("esbuild");
const url_1 = __importDefault(require("url"));
const async_sema_1 = require("async-sema");
const esbuild_plugins_node_modules_polyfill_1 = require("esbuild-plugins-node-modules-polyfill");
const core_1 = require("@babel/core");
const child_process_1 = require("child_process");
const console_1 = require("console");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const crypto_1 = __importDefault(require("crypto"));
const utils_js_1 = require("./utils.js");
const babel_jsx_js_1 = require("./babel-jsx.js");
const babel_typedoc_js_1 = require("./babel-typedoc.js");
const compat_js_1 = require("./compat.js");
const css_js_1 = require("./css.js");
const typescript_js_1 = require("./typescript.js");
const esbuild_2 = require("./esbuild");
const framer_js_1 = require("./framer.js");
const sentry_1 = require("./sentry");
const utils_js_2 = require("./utils.js");
const package_manager_js_1 = require("./package-manager.js");
const version_js_1 = require("./version.js");
const js_api_1 = require("@biomejs/js-api");
let biome;
const componentTypeCache = new Map();
// Helper to calculate file hash
async function getFileHash(filePath) {
    const content = await fs_1.default.promises.readFile(filePath, 'utf-8');
    return crypto_1.default.createHash('sha256').update(content).digest('hex');
}
async function bundle({ config, cwd: out = '', watch = false, signal = undefined, }) {
    const { components, breakpoints, tokens, framerWebPages } = config;
    out ||= path_1.default.resolve(process.cwd(), 'example');
    out = path_1.default.resolve(out);
    try {
        await fs_1.default.promises.mkdir(out, { recursive: true });
    }
    catch (e) { }
    // Prefix for temporary .js files to avoid HMR issues
    const tempJsPrefix = 'temp_';
    // Helper function to handle file path transformations with temp prefix
    function getFilePaths(filePath, outDir) {
        const baseName = path_1.default.basename(filePath);
        const dirName = path_1.default.dirname(filePath);
        const relativeDirname = path_1.default.relative(outDir, dirName);
        // chunks are imported, which means they should not have the temp_ prefix or imports will fail
        if (relativeDirname === 'chunks') {
            return {
                tempJsPath: path_1.default.resolve(outDir, filePath),
                finalJsPath: path_1.default.resolve(outDir, filePath),
                jsxPath: path_1.default.resolve(outDir, filePath.replace(/\.js$/, '.jsx')),
            };
        }
        const tempFileName = tempJsPrefix + baseName;
        const tempFilePath = path_1.default.join(dirName, tempFileName);
        return {
            tempJsPath: path_1.default.resolve(outDir, tempFilePath),
            finalJsPath: path_1.default.resolve(outDir, filePath),
            jsxPath: path_1.default.resolve(outDir, filePath.replace(/\.js$/, '.jsx')),
        };
    }
    utils_js_2.spinner.start('exporting components...');
    const otherRoutes = Object.fromEntries((config.framerWebPages || []).map((page) => [
        page.webPageId,
        { path: page.path },
    ]));
    const breakpointSizes = Object.entries(config.breakpoints || css_js_1.defaultBreakpointSizes).sort(([, a], [, b]) => a - b);
    function fakeContext(args) {
        return {
            rebuild() {
                return (0, esbuild_1.build)(args);
            },
            cancel() { },
            dispose() { },
        };
    }
    const fn = watch ? esbuild_1.context : fakeContext;
    const missingPackages = new Set();
    const buildContext = await fn({
        absWorkingDir: out,
        entryPoints: Object.keys(components)
            .filter((x) => x)
            .map((name) => {
            return {
                in: `virtual:${name}`,
                out: name,
            };
        }),
        jsx: 'automatic',
        // jsxFactory: '_jsx',
        bundle: true,
        platform: 'browser',
        metafile: true,
        format: 'esm',
        minify: false,
        treeShaking: true,
        splitting: true,
        logLevel: 'error',
        pure: ['addPropertyControls'],
        external: esbuild_2.defaultExternalPackages,
        chunkNames: 'chunks/[name]-[hash]',
        plugins: [
            (0, esbuild_2.esbuildPluginBundleDependencies)({
                signal,
                externalPackages: config.externalPackages,
                externalizeNpm: config.allExternal,
                outDir: out,
                onMissingPackage: (e) => {
                    // No longer needed - packages are auto-installed
                },
                onCollectMissingPackage: (pkg) => {
                    missingPackages.add(pkg);
                },
            }),
            (0, esbuild_plugins_node_modules_polyfill_1.nodeModulesPolyfillPlugin)({}),
            {
                name: 'virtual loader',
                setup(build) {
                    build.onResolve({ filter: /^virtual:.*/ }, (args) => {
                        return {
                            path: args.path.replace(/^virtual:/, ''),
                            namespace: 'virtual',
                        };
                    });
                    build.onLoad({ filter: /.*/, namespace: 'virtual' }, async (args) => {
                        const name = args.path;
                        // Handle virtual routes module
                        if (name === '__routes') {
                            return {
                                contents: `export const routes = ${JSON.stringify(otherRoutes, null, 2)};`,
                                loader: 'js',
                            };
                        }
                        const url = components[name];
                        const componentBreakpoints = config.componentBreakpoints?.filter((x) => x.componentName === name) || [];
                        const brk = breakpointSizes
                            .map(([name, width], index) => {
                            const nextWidth = breakpointSizes[index + 1]?.[1] ??
                                Infinity;
                            const matchingBreakpoint = componentBreakpoints.find((x) => x.width >= width &&
                                x.width < nextWidth);
                            if (!matchingBreakpoint) {
                                return [];
                            }
                            return [name, matchingBreakpoint.variantId];
                        })
                            .filter((x) => x.length);
                        const firstVariantId = brk.find((x) => x.length)?.[1];
                        const responsiveVariants = firstVariantId
                            ? Object.fromEntries([
                                ['base', firstVariantId],
                                ...brk.slice(1),
                            ])
                            : {};
                        // Use virtual routes module
                        const routesImportPath = 'virtual:__routes';
                        return {
                            contents: /** js **/ `
                                'use client'
                                import { Fragment } from 'react'
                                import { ContextProviders } from 'unframer'
                                import Component from '${await (0, esbuild_2.resolveRedirect)({
                                url,
                                signal,
                            })}'
                                import { WithFramerBreakpoints } from 'unframer'
                                import { routes } from '${routesImportPath}'
                                const locales = ${JSON.stringify(config.locales) || '[]'}
                                const defaultResponsiveVariants = ${JSON.stringify(responsiveVariants, null, 2)}


                                function ComponentWithRoot({ locale, ...rest }) {
                                    return (
                                        <ContextProviders
                                            routes={routes}
                                            children={<Component {...rest} />}
                                            framerSiteId={${JSON.stringify(config.fullFramerProjectId)}}
                                            locale={locale}
                                            locales={locales}
                                        />
                                    )
                                }
                                ComponentWithRoot.Responsive = ({ locale='', ...rest }) => {
                                    return (
                                        <ContextProviders
                                            routes={routes}
                                            children={<WithFramerBreakpoints
                                                        Component={Component}
                                                        variants={defaultResponsiveVariants}
                                                        {...rest}
                                                    />}
                                            framerSiteId={${JSON.stringify(config.fullFramerProjectId)}}
                                            locale={locale}
                                            locales={locales}
                                        />
                                    )
                                }
                                Object.assign(ComponentWithRoot, Component)
                                export default ComponentWithRoot
                                `,
                            loader: 'jsx',
                        };
                    });
                },
            },
        ],
        write: false,
        outdir: out,
    });
    const doNotEditComment = `/* This file was generated by Unframer for Framer project ${config.projectId || ''} "${config.projectName}", do not edit manually */\n`;
    async function rebuild() {
        // Clear missing packages for each rebuild (important for watch mode)
        missingPackages.clear();
        try {
            const installedVersion = await resolvePackageVersion({
                cwd: out,
                pkg: 'unframer',
            });
            if (isVersionGreater(installedVersion || '0.0.0', version_js_1.version || '0.0.0')) {
                // Version mismatch, add with specific version
                missingPackages.add(`unframer@${version_js_1.version}`);
                utils_js_2.spinner.info(`Different unframer version detected (${installedVersion}), will install unframer@${version_js_1.version}`);
            }
        }
        catch (e) {
            // Unframer not installed, add with specific version
            missingPackages.add(`unframer@${version_js_1.version}`);
            utils_js_2.spinner.info(`Missing package detected: unframer@${version_js_1.version}`);
        }
        const prevFiles = await recursiveReaddir(out);
        const buildResult = await buildContext.rebuild().catch((e) => {
            if (e.message.includes('No matching export ')) {
                utils_js_2.spinner.error(`esbuild failed to import from an external package, this usually means that the npm package version in Framer is older than the latest.`);
                utils_js_2.spinner.error(`Use --external to make all npm packagess external, then install the right version`);
                process.exit(1);
            }
            throw e;
        });
        utils_js_2.spinner.update('Finished build');
        // Install missing packages if any were collected
        if (missingPackages.size > 0) {
            const packagesToInstall = Array.from(missingPackages);
            utils_js_2.logger.log(`Installing missing packages: ${packagesToInstall.join(', ')}`);
            const installResult = await (0, package_manager_js_1.installPackagesBatch)({
                packageNames: packagesToInstall,
                cwd: out,
                isDev: false,
            });
            if (!installResult.success) {
                utils_js_2.spinner.error(`Failed to install packages: ${installResult.error}`);
                // Don't fail the build, just warn
            }
        }
        // First, write raw JS files for type extraction with temp prefix
        for (let file of buildResult.outputFiles) {
            const paths = getFilePaths(file.path, out);
            const prefix = `// @ts-nocheck\n` + `/* eslint-disable */\n` + doNotEditComment;
            const codeJs = prefix + file.text;
            utils_js_2.logger.log(`writing temp JS`, path_1.default.relative(out, paths.tempJsPath));
            await fs_1.default.promises.mkdir(path_1.default.dirname(paths.tempJsPath), {
                recursive: true,
            });
            await fs_1.default.promises.writeFile(paths.tempJsPath, codeJs, 'utf-8');
        }
        if (!buildResult?.outputFiles) {
            throw new Error('Failed to generate result');
        }
        const packageJson = path_1.default.resolve(out, 'package.json');
        await fs_1.default.promises.writeFile(packageJson, JSON.stringify({ type: 'module' }), 'utf-8');
        const sema = new async_sema_1.Sema(utils_js_2.stackblitzDemoExample ? 5 : 6);
        utils_js_2.spinner.update('Extracting types');
        utils_js_2.logger.log(`using node path`, nodePath);
        let allFonts = [];
        const propControlsData = await Promise.all(buildResult?.outputFiles.map(async (file) => {
            try {
                await sema.acquire();
                const name = path_1.default
                    .relative(out, file.path)
                    .replace(/\.jsx?$/, '');
                const paths = getFilePaths(file.path, out);
                const resultPathAbs = paths.tempJsPath;
                if (!components[name]) {
                    return;
                }
                if (!fs_1.default.existsSync(resultPathAbs)) {
                    utils_js_2.spinner.error(`cannot extract types for ${name}, missing output file`);
                    return;
                }
                // Only use cache in watch mode
                if (watch) {
                    // Check if we have a cached result for this file
                    const currentHash = await getFileHash(resultPathAbs);
                    const cacheKey = resultPathAbs;
                    const cachedEntry = componentTypeCache.get(cacheKey);
                    if (cachedEntry && cachedEntry.hash === currentHash) {
                        // File hasn't changed, use cached results
                        utils_js_2.logger.log(`using cached types for ${name}`);
                        // Add cached fonts to allFonts
                        if (cachedEntry.fonts) {
                            allFonts.push(...cachedEntry.fonts.map((x) => ({
                                ...x,
                                fileName: path_1.default.basename(file.path),
                            })));
                        }
                        return {
                            propertyControls: cachedEntry.propertyControls,
                            fonts: cachedEntry.fonts,
                            name,
                            typedocComments: cachedEntry.typedocComments,
                        };
                    }
                }
                // File has changed or not in cache, extract types
                utils_js_2.logger.log(`extracting types for ${name}`);
                utils_js_2.spinner.info(`Extracting types for component: ${name}`);
                utils_js_2.spinner.update(`Extracting types for ${name}`);
                const { propertyControls, fonts } = await extractPropControlsUnsafe(resultPathAbs, name);
                if (!propertyControls) {
                    utils_js_2.logger.log(`no property controls found for ${name}`);
                }
                allFonts.push(...(fonts || []).map((x) => ({
                    ...x,
                    fileName: path_1.default.basename(file.path),
                })));
                const componentImportedName = (0, typescript_js_1.componentCamelCase)(name);
                const typedocComments = (0, typescript_js_1.propControlsToTypedocComments)({
                    propertyControls: propertyControls,
                    logger: utils_js_2.logger,
                    componentImportedName,
                    locales: config.locales,
                    includeLocaleTypes: true,
                });
                utils_js_2.logger.log(`Generated TypeDoc comments for ${name}: ${!!typedocComments.headerComment}`);
                // Update cache (only if in watch mode)
                if (watch) {
                    const currentHash = await getFileHash(resultPathAbs);
                    const cacheKey = resultPathAbs;
                    componentTypeCache.set(cacheKey, {
                        hash: currentHash,
                        propertyControls,
                        fonts,
                        typedocComments,
                    });
                }
                return {
                    propertyControls,
                    fonts,
                    name,
                    typedocComments,
                };
            }
            finally {
                sema.release();
            }
        })).finally(async () => {
            try {
                await fs_1.default.promises.rm(packageJson);
            }
            catch (error) {
                // Ignore error if file doesn't exist or can't be deleted
            }
        });
        const cssString = doNotEditComment +
            '/* This css file has all the necessary styles to run all your Framer components */\n' +
            '@import "unframer/styles/reset.css";\n' +
            '@import "unframer/styles/framer.css";\n\n' +
            getStyleTokensCss(tokens || []) +
            (0, css_js_1.breakpointsStyles)(breakpoints) +
            '\n\n' +
            (0, css_js_1.getFontsStyles)(allFonts);
        await fs_1.default.promises.writeFile(path_1.default.resolve(out, 'styles.css'), cssString, 'utf-8');
        (0, css_js_1.logFontsUsage)(allFonts)
            ?.split('\n')
            .forEach((x) => utils_js_2.logger.log(x));
        const jsxFiles = buildResult.outputFiles
            .filter((x) => x.path.endsWith('.js') &&
            fs_1.default.existsSync(getFilePaths(x.path, out).jsxPath))
            .map((x) => getFilePaths(x.path, out).jsxPath);
        const outFiles = buildResult.outputFiles
            .map((x) => {
            const paths = getFilePaths(x.path, out);
            if (x.path.endsWith('.js') && fs_1.default.existsSync(paths.jsxPath)) {
                return null; // Will be handled by jsx files
            }
            return paths.finalJsPath;
        })
            .filter(Boolean)
            .concat([
            path_1.default.resolve(out, 'meta.json'),
            path_1.default.resolve(out, 'tokens.css'),
            path_1.default.resolve(out, '.cursorignore'),
            path_1.default.resolve(out, 'styles.css'),
        ])
            .concat(jsxFiles);
        const filesToDelete = prevFiles
            .filter((x) => !outFiles.includes(x))
            .filter((x) => !x.includes(tempJsPrefix)); // Don't delete temp files here, they're handled separately
        for (let file of filesToDelete) {
            utils_js_2.logger.log('deleting', path_1.default.relative(out, file));
            try {
                await fs_1.default.promises.rm(file);
            }
            catch (error) {
                // Ignore error if file doesn't exist or can't be deleted
            }
        }
        await fs_1.default.promises.writeFile(path_1.default.resolve(out, 'meta.json'), JSON.stringify(buildResult.metafile, null, 2), 'utf-8');
        if (signal?.aborted) {
            throw new Error('aborted');
        }
        if (watch) {
            utils_js_2.logger.log('waiting for components or config changes');
        }
        const res = {
            components: Object.entries(components).map(([name, v]) => {
                const propControls = propControlsData.find((x) => x?.name === name);
                return {
                    componentPathSlug: name,
                    url: v,
                    name,
                    componentName: (0, typescript_js_1.componentCamelCase)(name),
                    propertyControls: propControls?.propertyControls,
                };
            }),
        };
        // Process and write JSX files with TypeDoc comments
        utils_js_2.spinner.update('Processing JSX files with TypeDoc comments');
        for (let file of buildResult.outputFiles) {
            const paths = getFilePaths(file.path, out);
            const componentName = path_1.default
                .relative(out, file.path)
                .replace(/\.js$/, '');
            const propData = propControlsData.find((p) => p?.name === componentName);
            const typedocComments = propData?.typedocComments;
            utils_js_2.logger.log(`Processing component: ${componentName}`);
            utils_js_2.spinner.update(`Processing JSX for ${componentName}`);
            if (!propData) {
                utils_js_2.logger.log(`  No propData found for ${componentName}`);
            }
            else {
                utils_js_2.logger.log(`  PropData found for ${componentName}, has propertyControls: ${!!propData.propertyControls}`);
                if (!typedocComments) {
                    utils_js_2.logger.log(`  No typedocComments for ${componentName}`);
                }
                else {
                    utils_js_2.logger.log(`  TypeDoc comments available for ${componentName}`);
                }
            }
            const existing = await fs_1.default.promises
                .readFile(paths.jsxPath, 'utf-8')
                .catch(() => null);
            const tooBigSize = 0.7 * 1024 * 1024;
            let formatted = file.text;
            let tooBig = file.text.length >= tooBigSize;
            let didFormat = false;
            if (config.jsx &&
                !tooBig &&
                !paths.tempJsPath.includes('/chunks/') &&
                !paths.tempJsPath.includes('\\chunks\\')) {
                try {
                    const plugins = [
                        // babelPluginDeduplicateImports,
                        babel_jsx_js_1.babelPluginJsxTransform,
                        babel_jsx_js_1.removeJsxExpressionContainer,
                    ];
                    // Add TypeDoc plugin if we have comments for this component
                    if (typedocComments) {
                        utils_js_2.logger.log(`  Adding TypeDoc plugin for ${componentName}`);
                        plugins.push((0, babel_typedoc_js_1.babelPluginTypedoc)(typedocComments));
                    }
                    else {
                        utils_js_2.logger.log(`  No TypeDoc comments to add for ${componentName}`);
                    }
                    let res = (0, core_1.transform)(file.text || '', {
                        babelrc: false,
                        sourceType: 'module',
                        parserOpts: {
                            plugins: ['jsx'],
                        },
                        plugins,
                        // ast: true,
                        // code: false,
                        filename: 'x.jsx',
                        compact: false,
                        sourceMaps: false,
                    });
                    if (res?.code) {
                        if (!biome) {
                            biome = await js_api_1.Biome.create({
                                distribution: js_api_1.Distribution.NODE,
                            });
                        }
                        let result = biome.formatContent(res.code, {
                            filePath: 'example.jsx',
                        });
                        didFormat = true;
                        formatted = result.content;
                    }
                }
                catch (e) {
                    (0, sentry_1.notifyError)(e, 'babel transform and format');
                }
            }
            const prefix = `// @ts-nocheck\n` + `/* eslint-disable */\n` + doNotEditComment;
            const codeJsx = prefix + formatted;
            const codeJs = prefix + file.text;
            utils_js_2.logger.log(`writing`, path_1.default.relative(out, file.path));
            await fs_1.default.promises.mkdir(path_1.default.dirname(paths.jsxPath), {
                recursive: true,
            });
            // Always write the temp .js file for type extraction
            await fs_1.default.promises.writeFile(paths.tempJsPath, codeJs, 'utf-8');
            // Only write .jsx file if it's different from existing or if formatting was done
            if (didFormat && codeJsx !== existing) {
                await fs_1.default.promises.writeFile(paths.jsxPath, codeJsx, 'utf-8');
                utils_js_2.logger.log(`Updated JSX file for ${componentName}`);
            }
            else if (didFormat) {
                utils_js_2.logger.log(`JSX file unchanged for ${componentName}`);
            }
        }
        utils_js_2.spinner.stop();
        // await fs.promises.writeFile(
        //     path.resolve(out, '.cursorignore'),
        //     `**/*.js\nchunks\n`,
        //     'utf-8',
        // )
        // Clean up temp .js files and handle prefixes
        for (let file of buildResult.outputFiles) {
            if (file.path.endsWith('.js')) {
                const paths = getFilePaths(file.path, out);
                if (fs_1.default.existsSync(paths.jsxPath)) {
                    // Remove temp .js file if .jsx equivalent exists
                    utils_js_2.logger.log('removing temp JS file with JSX equivalent:', path_1.default.relative(out, paths.tempJsPath));
                    try {
                        await fs_1.default.promises.rm(paths.tempJsPath);
                        await fs_1.default.promises.rm(paths.finalJsPath);
                    }
                    catch (error) {
                        // Ignore error if file doesn't exist
                    }
                }
                else {
                    // Rename temp .js file to final name if no .jsx equivalent
                    utils_js_2.logger.log('renaming temp JS file to final name:', path_1.default.relative(out, paths.tempJsPath), '->', path_1.default.relative(out, paths.finalJsPath));
                    try {
                        await fs_1.default.promises.rename(paths.tempJsPath, paths.finalJsPath);
                    }
                    catch (error) {
                        // Ignore error if file doesn't exist
                    }
                }
            }
        }
        utils_js_2.spinner.info(`Build completed`);
        return res;
    }
    // when user press ctrl+c dispose
    process.on('SIGINT', async () => {
        utils_js_2.spinner.stop();
        console.log();
        await buildContext.cancel();
        buildContext.dispose();
        process.exit(0); // Ensure process exits
    });
    process.on('SIGABRT', async () => {
        utils_js_2.spinner.stop();
        console.log();
        await buildContext.cancel();
        buildContext.dispose();
        process.exit(0); // Ensure process exits
    });
    signal?.addEventListener('abort', async () => {
        await buildContext.cancel();
        buildContext.dispose();
    });
    const result = await rebuild();
    console.log();
    console.log();
    const outDirForExample = path_1.default
        .relative(process.cwd(), out)
        .split(path_1.default.sep)
        .join('/')
        .replace(/^src\//, '') || 'framer'; // remove src so file works inside src
    const { exampleCode } = await createExampleComponentCode({
        outDir: out,
        // buildResult: result,
        config,
    });
    if (utils_js_2.stackblitzDemoExample) {
        utils_js_2.logger.log(`Inside Stackblitz demo, writing App.tsx`);
        await fs_1.default.promises.mkdir(path_1.default.dirname(utils_js_2.stackblitzDemoExample), {
            recursive: true,
        });
        await fs_1.default.promises.writeFile(utils_js_2.stackblitzDemoExample, exampleCode);
    }
    // Build the output message
    let outputMessage = (0, utils_js_1.dedent) `
    # How to use the Framer components

    Your components are exported to \`${outDirForExample}\` folder.

    Each component has a \`.Responsive\` variant that allows you to specify different variants for different breakpoints.
    `;
    if (exampleCode) {
        outputMessage += (0, utils_js_1.dedent) `

        You can use the components like this (try copy pasting the code below into your React app):

        \`\`\`jsx
        ${exampleCode}
        \`\`\`
        `;
    }
    outputMessage += (0, utils_js_1.dedent) `

    Remember to import the \`styles.css\` file to include the necessary styles for the components.

    To style components you can pass a \`style\` or \`className\` prop (but remember to use !important to increase the specificity).

    Read more on GitHub: https://github.com/remorses/unframer
    `;
    console.log((0, utils_js_2.terminalMarkdown)(outputMessage));
    console.log();
    return { result, rebuild, buildContext };
}
const packageVersionCache = new Map();
function resolvePackageVersion({ cwd, pkg }) {
    if (packageVersionCache.has(pkg)) {
        return Promise.resolve(packageVersionCache.get(pkg));
    }
    return new Promise((resolve, reject) => {
        const code = `import('${pkg}/package.json', { with: { type: 'json' } }).then(pkg => console.log(pkg.version || pkg.default?.version));`;
        const command = [
            JSON.stringify(nodePath),
            '-e',
            JSON.stringify(code),
        ].join(' ');
        (0, child_process_1.exec)(command, {
            cwd,
        }, (error, stdout, stderr) => {
            if (error) {
                // Package not installed - this is expected and handled by auto-install
                reject(new Error(`${pkg} is not installed in your project`));
                return;
            }
            const version = stdout.trim();
            packageVersionCache.set(pkg, version);
            resolve(version);
        });
    });
}
function resolvePackage({ cwd, pkg }) {
    return new Promise((resolve) => {
        const code = `import('${pkg}/package.json', { with: { type: 'json' } }).then(()=>console.log('true')).catch(()=>import('${pkg}').then(()=>console.log('true')).catch(()=>console.log('false')));`;
        const command = [
            JSON.stringify(nodePath),
            '-e',
            JSON.stringify(code),
        ].join(' ');
        (0, child_process_1.exec)(command, {
            cwd,
        }, (error, stdout) => {
            if (error) {
                resolve(false);
                return;
            }
            const exists = stdout.trim().split('\n').pop() === 'true';
            resolve(exists);
        });
    });
}
function getDarkModeSelector(opts) {
    const { darkModeType = 'class', content } = opts;
    if (darkModeType === 'media') {
        return ('@media (prefers-color-scheme: dark) {\n' +
            '    :root {\n' +
            content +
            '\n' +
            '    }\n' +
            '}');
    }
    return '.dark {\n' + content + '\n' + '}';
}
function getStyleTokensCss(tokens, darkModeType = 'class') {
    if (!tokens?.length) {
        return '';
    }
    const lightUnframerTokens = tokens
        .map((token) => '    --unframer-' +
        (0, utils_js_2.kebabCase)(token.name || token.id) +
        ': ' +
        token.lightColor +
        ';')
        .join('\n');
    const lightTokens = tokens
        .map((token) => '    --token-' + token.id + ': ' + token.lightColor + ';')
        .join('\n');
    const darkUnframerTokens = tokens
        .map((token) => '    --unframer-' +
        (0, utils_js_2.kebabCase)(token.name || token.id) +
        ': ' +
        token.darkColor +
        ';')
        .join('\n');
    const darkTokens = tokens
        .map((token) => '    --token-' + token.id + ': ' + token.darkColor + ';')
        .join('\n');
    return (':root {\n' +
        lightUnframerTokens +
        '\n\n' +
        lightTokens +
        '\n' +
        '}\n\n' +
        getDarkModeSelector({
            darkModeType,
            content: darkUnframerTokens + '\n\n' + darkTokens,
        }));
}
function findRelativeLinks(text) {
    const regex = /webPageId:\s+/g;
    const lines = text.split('\n');
    const lineNumbers = new Set();
    for (let i = 0; i < lines.length; i++) {
        if (regex.test(lines[i])) {
            lineNumbers.add(i);
        }
    }
    return [...lineNumbers];
}
async function extractPropControlsSafe(text, name) {
    try {
        const propControlsCode = await parsePropertyControls(text);
        // console.log('propControlsCode', propControlsCode)
        const propControls = await Promise.resolve().then(async () => {
            if (!propControlsCode)
                return;
            const ivm = require('isolated-vm');
            const vm = new ivm.Isolate({ memoryLimit: 128 });
            const vmContext = vm.createContextSync();
            const jail = vmContext.global;
            let result = undefined;
            vmContext.global.setSync('__return', (x) => {
                result = x;
            });
            const mod = vm.compileModuleSync(`${text}`);
            await mod.instantiateSync(vmContext, (spec, mod) => {
                // TODO instantiate framer, react, framer-motion etc
                return;
            });
            await mod.evaluate({});
            return result;
        });
        if (!propControls) {
            utils_js_2.logger.error(`no property controls found for component ${name}`);
            return;
        }
        return propControls;
    }
    catch (e) {
        (0, sentry_1.notifyError)(console_1.error, 'typescript generation error');
        utils_js_2.logger.error(`Cannot get property controls for ${name}`, e.stack);
    }
}
async function getTokensCss({ out, result, }) {
    const allTokens = [];
    for (let file of result.outputFiles) {
        const code = fs_1.default.readFileSync(path_1.default.resolve(out, file.path), 'utf-8');
        const tokens = extractTokenInfo(code);
        // console.log('tokens', tokens)
        for (let token of tokens) {
            const already = allTokens.find((x) => x.tokenName === token.tokenName);
            const filePath = path_1.default.relative(out, file.path);
            const filePaths = (() => {
                if (!filePath.startsWith('chunk-')) {
                    return [filePath];
                }
                const files = Object.entries(result.metafile.outputs).filter(([k, v]) => {
                    const filename = path_1.default.basename(k);
                    if (filename.startsWith('chunk-')) {
                        return false;
                    }
                    const doesItImport = v.imports.find((x) => x.path === filePath);
                    return doesItImport;
                });
                return files.map(([k, v]) => k);
            })();
            if (!token?.tokenName?.startsWith('--token')) {
                continue;
            }
            if (!already) {
                allTokens.push({
                    tokenName: token.tokenName,
                    defaultValues: new Set([token.defaultValue]),
                    nameAnnotation: token.metadata?.name,
                    usedBy: new Set([...filePaths]),
                });
            }
            else {
                already.defaultValues.add(token.defaultValue);
                if (!already.nameAnnotation && token.metadata?.name) {
                    already.nameAnnotation = token.metadata.name;
                }
                filePaths.map((x) => already.usedBy.add(x));
            }
        }
    }
    const groupedByUsers = (0, css_js_1.groupBy)(allTokens, (x) => {
        const str = `/* Used by ${[...x.usedBy].sort().join(', ')} */`;
        return str;
    });
    const cssStrings = [...groupedByUsers.entries()]
        .map(([usedBy, x]) => {
        return (`    /* Used by ${[...x[0].usedBy].sort().join(', ')} */\n` +
            [...x]
                .map((x) => {
                const possibleValues = [...x.defaultValues].sort();
                let comment = '';
                comment += x.nameAnnotation
                    ? ` Named as ${JSON.stringify(x.nameAnnotation)} in Framer.`
                    : '';
                comment +=
                    possibleValues.length > 1
                        ? ` Also seen as ${possibleValues
                            .slice(1)
                            .join(', ')}.`
                        : '';
                return `    ${x.tokenName}: ${possibleValues[0]}; ${comment ? `/*${comment} */` : ''}`;
            })
                .join('\n'));
    })
        .join('\n');
    const tokensCss = `:root {\n${cssStrings}\n}`;
    return tokensCss;
}
const nodePath = process.argv[0] || 'node';
async function extractPropControlsUnsafe(filename, name) {
    const delimiter = '__delimiter__';
    let propCode = `JSON.stringify({propertyControls: x.default?.propertyControls, fonts: x?.default?.fonts } || {}, null, 2)`;
    const fileUrl = url_1.default.pathToFileURL(filename).href;
    const code = `import('${fileUrl}').then(x => { console.log('${delimiter}'); console.log(${propCode}) })`;
    const TIMEOUT = 5 * 1000;
    const UNFRAMER_MAP_PACKAGES = {
        unframer: url_1.default.pathToFileURL(require.resolve('../esm/index.js')).href,
        react: url_1.default.pathToFileURL(require.resolve('react')).href,
        'react-dom': url_1.default.pathToFileURL(require.resolve('react-dom')).href,
        'react/jsx-runtime': url_1.default.pathToFileURL(require.resolve('react/jsx-runtime')).href,
    };
    let loaderOption = `--loader "${url_1.default.pathToFileURL(require.resolve('../dist/unframer-loader.js'))}"`;
    try {
        require.resolve('unframer/package.json');
        UNFRAMER_MAP_PACKAGES.unframer = '';
    }
    catch { }
    let stdout = await new Promise((res, rej) => {
        const cmd = `"${nodePath}" --no-warnings --input-type=module ${loaderOption} -e "${code}"`;
        let childProcess = (0, child_process_1.exec)(cmd, {
            env: {
                // ...process.env,
                UNFRAMER_MAP_PACKAGES: JSON.stringify(UNFRAMER_MAP_PACKAGES),
            },
        }, (err, stdout, stderr) => {
            clearTimeout(timer);
            if (err) {
                utils_js_2.spinner.error(`error extracting types for ${name}`);
                console.error(stderr);
                return rej(err);
            }
            res(stdout);
        });
        const timer = setTimeout(() => {
            childProcess.kill();
            rej(new Error(`Timed out after ${TIMEOUT}ms while extracting types for ${name}`));
        }, TIMEOUT);
    }).catch((e) => {
        utils_js_2.logger.log(e.stack);
        return '';
    });
    stdout = stdout.split(delimiter)[1] || '';
    if (!stdout) {
        return {};
    }
    // console.log(stdout)
    return safeJsonParse(stdout);
}
function safeJsonParse(text) {
    try {
        return JSON.parse(text);
    }
    catch (e) {
        utils_js_2.logger.error('cannot parse json', text.slice(0, 100));
        return null;
    }
}
function parsePropertyControls(code) {
    const start = code.indexOf('addPropertyControls(');
    if (start === -1) {
        utils_js_2.logger.error('no addPropertyControls call found');
        return null;
    }
    // count all parentheses to find when the addPropertyControls ends
    let openParentheses = 0;
    let closedParentheses = 0;
    let current = start;
    // parses using parentheses
    while (current < code.length) {
        const newP = code.indexOf('(', current);
        const newC = code.indexOf(')', current);
        if (newP === -1 && newC === -1) {
            break;
        }
        if (newP !== -1 && newP < newC) {
            openParentheses++;
            current = newP + 1;
        }
        if (newC !== -1 && newC < newP) {
            closedParentheses++;
            current = newC + 1;
        }
        if (openParentheses === closedParentheses) {
            break;
        }
    }
    const end = current;
    const propControls = code.substring(start, end);
    const realStart = propControls.indexOf(',');
    if (realStart === -1) {
        return '';
    }
    return propControls.slice(realStart + 1, -1);
}
function extractTokenInfo(code) {
    const lines = code.split('\n');
    const tokenLines = lines.filter((line) => line.includes('var(--token'));
    const tokens = [];
    for (const line of tokenLines) {
        let startIndex = 0;
        while (startIndex < line.length) {
            startIndex = line.indexOf('var(--', startIndex);
            if (startIndex === -1) {
                break;
            }
            let parCount = 0;
            let varStatement = '';
            for (let i = startIndex + 3; i < line.length; i++) {
                if (line[i] === '(') {
                    parCount++;
                }
                else if (line[i] === ')') {
                    parCount--;
                }
                varStatement += line[i];
                if (parCount === 0) {
                    break;
                }
            }
            varStatement = varStatement.trim().slice(1).slice(0, -1); // Remove starting and closing parenthesis
            const [tokenName, defaultValue] = splitOnce(varStatement, ',');
            let metadata;
            const jsonStartIndex = line.indexOf('/*', startIndex);
            if (jsonStartIndex !== -1) {
                const jsonEndIndex = line.indexOf('*/', jsonStartIndex);
                if (jsonEndIndex !== -1) {
                    const jsonString = line
                        .slice(jsonStartIndex + 2, jsonEndIndex)
                        .trim();
                    try {
                        metadata = JSON.parse(jsonString);
                    }
                    catch (error) {
                        // console.warn('Failed to parse JSON metadata:', error)
                    }
                }
            }
            if (tokenName && defaultValue) {
                tokens.push({
                    tokenName,
                    defaultValue: defaultValue.trim(),
                    metadata,
                });
            }
            startIndex += varStatement.length + 'var(--'.length; // Move the startIndex to the end of the current var(--token)
        }
    }
    return tokens;
}
function splitOnce(str, separator) {
    const index = str.indexOf(separator);
    if (index === -1) {
        return [str];
    }
    return [str.slice(0, index), str.slice(index + 1)];
}
const breakpointVariants = ['mobile', 'tablet', 'desktop'];
function getVariantsFromPropControls(propControls) {
    if (!propControls?.variant) {
        return null;
    }
    let variants = propControls.variant?.['optionTitles'] ||
        propControls.variant?.['options'] ||
        [];
    // Sort breakpoint-related variants first
    return {
        variants: variants,
        breakpoints: variants.filter((v) => breakpointVariants.some((device) => v.toLowerCase().includes(device))),
    };
}
function findExampleProperty(propertyControls) {
    if (!propertyControls) {
        return null;
    }
    const stringProp = Object.entries(propertyControls).find(([_, control]) => {
        // console.log('control', _, control)
        return control?.type === framer_js_1.ControlType.String;
    });
    if (!stringProp) {
        return null;
    }
    return (0, compat_js_1.propCamelCaseJustLikeFramer)(stringProp[1]?.title || '');
}
async function recursiveReaddir(dir) {
    const dirents = await fs_1.default.promises.readdir(dir, { withFileTypes: true });
    const files = await Promise.all(dirents.map((dirent) => {
        const res = path_1.default.resolve(dir, dirent.name);
        return dirent.isDirectory() ? recursiveReaddir(res) : res;
    }));
    return files.flat();
}
function indentWithTabs(str, tabs) {
    if (!str)
        return '';
    return str
        .split('\n')
        .map((line, i) => (!i ? line : tabs + line))
        .join('\n');
}
async function createExampleComponentCode({ outDir, config, }) {
    const outDirForExample = path_1.default
        .relative(process.cwd(), outDir)
        .split(path_1.default.sep)
        .join('/')
        .replace(/^src\//, ''); // remove src so file works inside src
    const instances = config?.componentInstancesInIndexPage?.sort((a, b) => {
        // Order first by nodeDepth (lower is better)
        return a.nodeDepth - b.nodeDepth || a.pageOrdering - b.pageOrdering;
    });
    if (!instances?.length)
        return { outDirForExample, exampleCode: '' };
    const imports = instances?.map((exampleComponent) => {
        return `import ${(0, typescript_js_1.componentCamelCase)(exampleComponent?.componentPathSlug)} from './${outDirForExample}/${exampleComponent?.componentPathSlug}'`;
    });
    const jsx = instances?.map((exampleComponent) => {
        let propStr = '';
        for (let [key, value] of Object.entries(exampleComponent.controls || {})) {
            if (key === 'variant') {
                continue;
            }
            if (typeof value === 'object') {
                continue;
            }
            // TODO get property controls to render enums much better? maybe do this in plugin instead
            propStr += '\n';
            propStr += `  ${key}={${JSON.stringify(value)}}`;
        }
        if (propStr)
            propStr += '\n';
        const responsiveComponent = `<${(0, typescript_js_1.componentCamelCase)(exampleComponent?.componentPathSlug)}.Responsive${propStr}/>`;
        return responsiveComponent;
    });
    if (!jsx.join().trim())
        return { outDirForExample, exampleCode: '' };
    let containerClasses = '';
    if (config.pageBackgroundColor) {
        let bg = config.pageBackgroundColor?.replace(' ', '_');
        containerClasses += `bg-[${bg}]`;
    }
    const exampleCode = (0, utils_js_1.dedent) `
      import './${outDirForExample}/styles.css'

      ${indentWithTabs(imports?.join('\n'), '')}

      export default function App() {
        return (
          <div className='flex flex-col items-center gap-3 ${containerClasses}'>
            ${indentWithTabs(jsx?.join('\n'), '      ')}
          </div>
        );
      };
      `;
    return {
        outDirForExample,
        exampleCode,
    };
}
/**
 * Compares two semantic version strings.
 * Returns true if versionB is greater than versionA.
 * Handles x.y.z, x.y, x, and optional pre-release (-alpha, etc).
 */
function isVersionGreater(versionA, versionB) {
    try {
        function parseVersion(version) {
            // Remove pre-release (e.g. -alpha.1)
            let [core] = version.trim().split('-');
            return core.split('.').map((x) => parseInt(x, 10));
        }
        const [a1 = 0, a2 = 0, a3 = 0] = parseVersion(versionA);
        const [b1 = 0, b2 = 0, b3 = 0] = parseVersion(versionB);
        if (b1 > a1)
            return true;
        if (b1 < a1)
            return false;
        if (b2 > a2)
            return true;
        if (b2 < a2)
            return false;
        if (b3 > a3)
            return true;
        if (b3 < a3)
            return false;
        // If all equal, not greater
        return false;
    }
    catch (error) {
        utils_js_2.spinner.error(`Error comparing versions "${versionA}" and "${versionB}": ${error?.stack || error?.message || error}`);
        return true;
    }
}
//# sourceMappingURL=exporter.js.map