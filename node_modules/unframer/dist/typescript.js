"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.componentCamelCase = componentCamelCase;
exports.propControlsToTypedocComments = propControlsToTypedocComments;
const compat_js_1 = require("./compat.js");
const framer_js_1 = require("./framer.js");
function componentCamelCase(str) {
    str = str?.replace(/\.jsx?$/, '');
    if (!str) {
        return 'FramerComponent';
    }
    // Take last part after slashes
    str = str.split('/').filter(Boolean).pop() || '';
    // Replace all non-alphanumeric characters with space
    // This handles spaces, special chars, underscores, hyphens, etc.
    str = str.replace(/[^a-zA-Z0-9]+/g, ' ');
    // Convert to camelCase: split by spaces, capitalize each word except first
    const words = str.trim().split(/\s+/).filter(Boolean);
    if (words.length === 0) {
        return 'FramerComponent';
    }
    str = words
        .map((word, index) => {
        // First word: capitalize only if it starts with lowercase
        if (index === 0) {
            return word[0].toUpperCase() + word.slice(1);
        }
        // Other words: always capitalize first letter
        return word[0].toUpperCase() + word.slice(1);
    })
        .join('');
    // If component name starts with a number, add prefix 'Framer'
    if (/^[0-9]/.test(str)) {
        str = 'Framer' + str;
    }
    str = str + 'FramerComponent';
    return str;
}
/**
 * Generates TypeDoc comments that will be injected into JSX files
 * instead of generating separate .d.ts files
 */
function propControlsToTypedocComments({ locales, componentImportedName, propertyControls, logger, includeLocaleTypes = false, }) {
    try {
        const types = Object.entries(propertyControls || {})
            .map(([key, value]) => {
            if (!value) {
                return;
            }
            const typescriptType = (value) => {
                value.type;
                switch (value.type) {
                    case framer_js_1.ControlType.Color:
                        return 'string';
                    case framer_js_1.ControlType.Boolean:
                        return 'boolean';
                    case framer_js_1.ControlType.Number:
                        return 'number';
                    case framer_js_1.ControlType.String:
                        return 'string';
                    case framer_js_1.ControlType.Enum: {
                        // @ts-expect-error
                        const options = value.optionTitles || value.options;
                        return options.map((x) => `'${x}'`).join(' | ');
                    }
                    case framer_js_1.ControlType.File:
                        return 'string';
                    case framer_js_1.ControlType.Image:
                        return 'string';
                    case framer_js_1.ControlType.ComponentInstance:
                        return 'React.ReactNode';
                    case framer_js_1.ControlType.Array:
                        // @ts-expect-error
                        return `${typescriptType(value.control)}[]`;
                    case framer_js_1.ControlType.Object:
                        // @ts-expect-error
                        return `{${Object.entries(value.controls)
                            .map(([k, v]) => {
                            // @ts-expect-error
                            return `${k}: ${typescriptType(v)}`;
                        })
                            .join(', ')}`;
                    case framer_js_1.ControlType.Date:
                        return 'string | Date';
                    case framer_js_1.ControlType.Link:
                        return 'string';
                    case framer_js_1.ControlType.ResponsiveImage:
                        return `{src: string, srcSet?: string, alt?: string}`;
                    case framer_js_1.ControlType.FusedNumber:
                        return 'number';
                    case framer_js_1.ControlType.Transition:
                        return 'any';
                    case framer_js_1.ControlType.EventHandler:
                        return 'Function';
                }
            };
            let name = (0, compat_js_1.propCamelCaseJustLikeFramer)(value.title || key || '');
            if (!name) {
                return '';
            }
            return ` * ${name}?: ${typescriptType(value)} // ${value.title || name}`;
        })
            .filter(Boolean)
            .join('\n');
        const componentName = componentImportedName;
        const defaultPropsJsDoc = [
            ' * children?: React.ReactNode',
            includeLocaleTypes ? ' * locale?: Locale' : null,
            ' * style?: React.CSSProperties',
            ' * className?: string',
            ' * id?: string',
            ' * ref?: any',
            ' * width?: any',
            ' * height?: any',
            ' * layoutId?: string',
        ].filter(Boolean).join('\n');
        // Generate header comment with type definitions
        let headerComment = '';
        if (includeLocaleTypes) {
            headerComment += '/**\n';
            headerComment += ' * @typedef Locale\n';
            // Generate union type from locales if available
            const localeType = (() => {
                if (locales && Array.isArray(locales) && locales.length > 0) {
                    return locales.map((locale) => `'${locale.slug}'`).join(' | ');
                }
                return 'string';
            })();
            headerComment += ` * ${localeType}\n`;
            headerComment += ' */\n\n';
        }
        headerComment += '/**\n';
        headerComment += ' * @typedef {{\n';
        headerComment += defaultPropsJsDoc;
        if (types) {
            headerComment += '\n' + types;
        }
        headerComment += `\n}} Props\n`;
        headerComment += '\n */';
        // Generate responsive comment
        let responsiveComment = '/**\n';
        responsiveComment += ' * @type {import("unframer").UnframerBreakpoint}\n';
        responsiveComment += ' * Represents a responsive breakpoint for unframer.\n';
        responsiveComment += ' */\n\n';
        responsiveComment += '/**\n';
        responsiveComment += ' * @typedef VariantsMap\n';
        responsiveComment += " * Partial record of UnframerBreakpoint to Props.variant, with a mandatory 'base' key.\n";
        responsiveComment += " * { [key in UnframerBreakpoint]?: Props['variant'] } & { base: Props['variant'] }\n";
        responsiveComment += ' */\n\n';
        responsiveComment += `/**\n * Renders ${componentName} for all breakpoints with a variants map. Variant prop is inferred per breakpoint.\n * @function\n * @param {Omit<Props, 'variant'> & {variants?: VariantsMap}} props\n * @returns {any}\n */`;
        // Generate default export comment - use inline function type instead of referencing undefined type
        const defaultExportComment = `/** @type {function(Props): any} */`;
        return {
            headerComment,
            responsiveComment,
            defaultExportComment,
        };
    }
    catch (e) {
        logger.error(e.message);
        logger.error('cannot generate typedoc comments', e.stack);
        return {
            headerComment: '',
            responsiveComment: '',
            defaultExportComment: '',
        };
    }
}
//# sourceMappingURL=typescript.js.map