"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cli = void 0;
exports.configFromFetch = configFromFetch;
const events_1 = require("events");
const undici_1 = require("undici");
require("./sentry.js");
const exporter_js_1 = require("./exporter.js");
const api_client_js_1 = require("./generated/api-client.js");
const cac_1 = require("cac");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importStar(require("path"));
const css_js_1 = require("./css.js");
const utils_js_1 = require("./utils.js");
const sentry_js_1 = require("./sentry.js");
const undici_dispatcher_js_1 = require("./undici-dispatcher.js");
const configNames = ['unframer.config.json', 'unframer.json'];
exports.cli = (0, cac_1.cac)('unframer');
let defaultOutDir = 'framer';
exports.cli.command('[projectId]', 'Run unframer with optional project ID')
    .option('--outDir <dir>', 'Output directory', { default: defaultOutDir })
    .option('--external [package]', 'Make some package external, do not pass a package name to make all packages external', {
    default: true,
})
    .option('--watch', 'Watch for changes and rebuild', { default: false })
    .option('--jsx', 'Output jsx code instead of minified .js code', {
    default: true,
})
    .option('--debug', 'Enable debug logging', { default: false })
    .action(async function main(projectId, options) {
    const external_ = options.external;
    const allExternal = external_ === true;
    const externalPackages = Array.isArray(external_)
        ? external_.filter((x) => x.trim())
        : typeof external_ === 'string'
            ? [external_]
            : [];
    try {
        if (options.debug) {
            utils_js_1.logger.debug = true;
        }
        const outDir = options.outDir;
        const controller = new AbortController();
        const signal = controller.signal;
        const watch = options.watch;
        if (projectId) {
            const { config, cwd, websiteUrl } = await configFromFetch({
                allExternal,
                externalPackages,
                outDir,
                projectId,
            });
            let jsx = options.jsx;
            const { rebuild, buildContext } = await (0, exporter_js_1.bundle)({
                config: {
                    jsx,
                    ...config,
                },
                watch,
                cwd,
                signal,
            });
            // console.log('buildContext', buildContext)
            if (!websiteUrl || !options.watch) {
                await buildContext?.dispose?.();
                return;
            }
            utils_js_1.spinner.start(`Waiting for changes, try editing a component in Framer and click publish...`);
            let lastEtag = null;
            const startTime = Date.now();
            while (Date.now() - startTime < 30 * 60 * 1000) {
                const etag = await (0, undici_1.fetch)(websiteUrl, {
                    method: 'HEAD',
                    dispatcher: undici_dispatcher_js_1.dispatcher,
                })
                    .then((response) => response.headers.get('etag'))
                    .catch((error) => {
                    utils_js_1.logger.error('Error fetching etag:', error);
                    return null;
                });
                utils_js_1.logger.log('etag', etag);
                if (etag && lastEtag && etag !== lastEtag) {
                    utils_js_1.spinner.start(`Detected Framer website change, rebuilding...`);
                    lastEtag = etag;
                    await rebuild();
                }
                if (etag) {
                    lastEtag = etag;
                }
                await (0, utils_js_1.sleep)(1000 * 2);
            }
        }
        // legacy behavior without Framer plugin
        fixOldUnframerPath();
        const cwd = process.cwd();
        utils_js_1.logger.log(`Looking for ${configNames.join(', ')} in ${cwd}`);
        const configPath = findUp(configNames, { cwd });
        if (!configPath) {
            utils_js_1.logger.log(`No ${configNames.join(', ')} found`);
            return;
        }
        const configBasename = (0, path_1.basename)(configPath);
        const configContent = fs_1.default.readFileSync(configPath, 'utf8');
        if (!configContent) {
            utils_js_1.logger.log(`No ${configBasename} contents found`);
            return;
        }
        const configContentWithoutComments = configContent.replace(/^\s*\/\/.*$/gm, '');
        const config = JSON.parse(configContentWithoutComments);
        if (outDir !== defaultOutDir) {
            config.outDir = outDir;
        }
        (0, events_1.setMaxListeners)(0, controller.signal);
        const { buildContext } = await (0, exporter_js_1.bundle)({
            config: { ...config, externalPackages, allExternal },
            watch,
            signal: controller.signal,
            cwd: path_1.default.resolve(process.cwd(), config.outDir || 'framer'),
        });
        await buildContext.dispose?.();
    }
    catch (error) {
        (0, sentry_js_1.notifyError)(error);
        throw error;
    }
});
const defaultConfig = `{
    "schema": "https://unframer-schema.vercel.app/schema.json",
    "outDir": "./framer",
    "components": {
        // add here your Framer components urls, the code will be written to outDir/{componentName}.js
        "example-hero": "https://framer.com/m/Header-WtSW.js",
    }
}
`;
function fixOldUnframerPath() {
    // if unframer.json exists, rename it to unframer.config.json
    const oldConfigPath = fs_1.default.existsSync('unframer.json');
    if (oldConfigPath) {
        fs_1.default.renameSync('unframer.json', 'unframer.config.json');
        utils_js_1.logger.green('legacy unframer.json config renamed to unframer.config.json');
        return true;
    }
    return false;
}
const package_json_1 = __importDefault(require("../package.json"));
const version = package_json_1.default.version;
exports.cli.version(version).help();
exports.cli.command('init', 'Init the unframer.config.json config').action(async (options) => {
    let fixed = fixOldUnframerPath();
    if (fixed) {
        return;
    }
    fs_1.default.writeFileSync(`unframer.config.json`, defaultConfig);
    const p = path_1.default.resolve(process.cwd(), 'unframer.config.json');
    console.log(`${p} file created`);
});
async function configFromFetch({ projectId, externalPackages = [], allExternal = false, outDir = undefined, }) {
    utils_js_1.logger.log(`Fetching config for project ${projectId}`);
    const url = process.env.UNFRAMER_SERVER_URL;
    if (url) {
        console.log(`using server url ${url}`);
    }
    const client = await (0, api_client_js_1.createClient)({
        url: url || 'https://unframer.co',
    });
    utils_js_1.spinner.start(`Fetching config for project ${projectId}`);
    const { data, error } = await client.api.plugins.reactExportPlugin
        .project({ projectId })
        .get();
    if (error) {
        utils_js_1.spinner.error('Error fetching project data:');
        console.error(error);
        throw error;
    }
    utils_js_1.spinner.info(`Got Framer project data`);
    const websiteUrl = data?.project?.websiteUrl;
    const projectName = data?.project?.projectName || '';
    if (projectName) {
        utils_js_1.spinner.info(`Using project: ${projectName}`);
    }
    let cwd = path_1.default.resolve(process.cwd(), outDir || 'framer');
    const indexPage = data?.framerWebPages?.find((x) => x.path === '/');
    const componentInstancesInIndexPage = data.componentInstances
        ?.filter((x) => x.webPageId === indexPage?.webPageId)
        .map((x) => {
        const component = data.components.find((c) => {
            return x.componentId === c.id;
        });
        if (!component) {
            console.error(new Error(`cannot find component for instance ${x.componentId}`));
        }
        const componentPathSlug = (0, utils_js_1.componentNameToPath)(component?.name || '');
        const res = {
            ...x,
            controls: x.controls,
            componentPathSlug,
        };
        return res;
    })
        .sort((a, b) => {
        return a.pageOrdering - b.pageOrdering;
    }) || [];
    const config = {
        ...data,
        pageBackgroundColor: data.project?.pageBackgroundColor || '',
        breakpoints: css_js_1.defaultBreakpointSizes,
        outDir,
        externalPackages,
        allExternal,
        projectId: data?.project?.projectId,
        projectName,
        fullFramerProjectId: data?.project?.fullFramerProjectId,
        locales: data?.locales,
        components: Object.fromEntries(data.components.map((c) => [(0, utils_js_1.componentNameToPath)(c.name), c.url])),
        componentBreakpoints: data.breakpoints
            ?.map((b) => {
            const c = data.components.find((c) => c.id === b.componentId);
            if (!c) {
                return;
            }
            return {
                ...b,
                componentName: (0, utils_js_1.componentNameToPath)(c.name),
            };
        })
            .filter(utils_js_1.isTruthy) || [],
        tokens: data.colorStyles,
        componentInstancesInIndexPage,
        framerWebPages: data.framerWebPages || [],
    };
    return { websiteUrl, cwd, config };
}
function findUp(configNames, { cwd }) {
    let currentDir = cwd;
    while (true) {
        for (const configName of configNames) {
            const configPath = path_1.default.join(currentDir, configName);
            if (fs_1.default.existsSync(configPath)) {
                return configPath;
            }
        }
        const parentDir = path_1.default.dirname(currentDir);
        if (parentDir === currentDir) {
            // Reached the root directory
            break;
        }
        currentDir = parentDir;
    }
    return null;
}
//# sourceMappingURL=cli.js.map