"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlatCacheStore = void 0;
// FlatCacheStore.ts
const node_stream_1 = require("node:stream");
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const node_os_1 = require("node:os");
const node_crypto_1 = require("node:crypto");
const utils_1 = require("./utils");
/**
 * A CacheStore that persists each entry as separate files in os.tmpdir()/.unframer.
 * Each cache entry creates a .json file for metadata and a .bin file for the body.
 * It satisfies the exact same interface that `MemoryCacheStore` and
 * `SqliteCacheStore` implement inside Undici (see cache-interceptor.d.ts).
 */
class FlatCacheStore {
    cacheDir;
    constructor({ cacheDir }) {
        this.cacheDir = (0, node_path_1.join)((0, node_os_1.tmpdir)(), cacheDir);
        utils_1.logger.log(`using cache dir`, this.cacheDir);
        this.ensureCacheDir();
    }
    async ensureCacheDir() {
        try {
            await node_fs_1.promises.mkdir(this.cacheDir, { recursive: true });
        }
        catch (error) {
            // Directory might already exist, ignore error
        }
    }
    getFileHash(key) {
        return (0, node_crypto_1.createHash)('sha256').update(JSON.stringify(key)).digest('hex');
    }
    getFilePaths(key) {
        const hash = this.getFileHash(key);
        return {
            metaPath: (0, node_path_1.join)(this.cacheDir, `${hash}.json`),
            bodyPath: (0, node_path_1.join)(this.cacheDir, `${hash}.bin`),
        };
    }
    /** Read a cached response (metadata + body) */
    async get(key) {
        try {
            const { metaPath, bodyPath } = this.getFilePaths(key);
            const [metaData, bodyData] = await Promise.all([
                node_fs_1.promises.readFile(metaPath, 'utf-8'),
                node_fs_1.promises.readFile(bodyPath),
            ]);
            const meta = JSON.parse(metaData);
            return {
                ...meta,
                body: bodyData,
            };
        }
        catch (error) {
            return undefined;
        }
    }
    /** Return a writable stream so the interceptor can pipe the body into us */
    createWriteStream(key, meta) {
        const chunks = [];
        return new node_stream_1.Writable({
            write(chunk, _enc, cb) {
                chunks.push(chunk);
                cb();
            },
            final: async (cb) => {
                try {
                    await this.ensureCacheDir();
                    const { metaPath, bodyPath } = this.getFilePaths(key);
                    await Promise.all([
                        node_fs_1.promises.writeFile(metaPath, JSON.stringify(meta, null, 2)),
                        node_fs_1.promises.writeFile(bodyPath, Buffer.concat(chunks)),
                    ]);
                    cb();
                }
                catch (error) {
                    cb(error);
                }
            },
        });
    }
    /** Delete one entry */
    async delete(key) {
        try {
            const { metaPath, bodyPath } = this.getFilePaths(key);
            await Promise.all([
                node_fs_1.promises.unlink(metaPath).catch(() => { }),
                node_fs_1.promises.unlink(bodyPath).catch(() => { }),
            ]);
        }
        catch (error) {
            // Ignore errors when deleting non-existent files
        }
    }
}
exports.FlatCacheStore = FlatCacheStore;
//# sourceMappingURL=flat-cache-interceptor.js.map