{"version":3,"file":"wheel-gestures.cjs.production.min.js","sources":["../src/utils/projection.ts","../src/utils/index.ts","../src/wheel-normalizer/wheel-normalizer.ts","../src/wheel-gestures/options.ts","../src/wheel-gestures/wheel-gestures.ts","../src/events/EventBus.ts","../src/wheel-gestures/state.ts","../src/wheel-gestures/constants.ts","../src/events/WheelTargetObserver.ts"],"sourcesContent":["const DECAY = 0.996\n\n/**\n * movement projection based on velocity\n * @param velocityPxMs\n * @param decay\n */\nexport const projection = (velocityPxMs: number, decay = DECAY) => (velocityPxMs * decay) / (1 - decay)\n","export * from './projection'\n\nexport function lastOf<T>(array: T[]) {\n  return array[array.length - 1]\n}\n\nexport function average(numbers: number[]) {\n  return numbers.reduce((a, b) => a + b) / numbers.length\n}\n\nexport const clamp = (value: number, min: number, max: number) => Math.min(Math.max(min, value), max)\n\nexport function addVectors<T extends number[]>(v1: T, v2: T): T {\n  if (v1.length !== v2.length) {\n    throw new Error('vectors must be same length')\n  }\n  return v1.map((val, i) => val + v2[i]) as T\n}\n\nexport function absMax(numbers: number[]) {\n  return Math.max(...numbers.map(Math.abs))\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function deepFreeze<T extends object>(o: T): Readonly<T> {\n  Object.freeze(o)\n  Object.values(o).forEach((value) => {\n    if (value !== null && typeof value === 'object' && !Object.isFrozen(value)) {\n      deepFreeze(value)\n    }\n  })\n  return o\n}\n","import { ReverseSign, VectorXYZ, WheelEventData } from '../types'\nimport { clamp } from '../utils'\n\nexport interface NormalizedWheel {\n  axisDelta: VectorXYZ\n  timeStamp: number\n}\n\nconst LINE_HEIGHT = 16 * 1.125\nconst PAGE_HEIGHT = (typeof window !== 'undefined' && window.innerHeight) || 800\nconst DELTA_MODE_UNIT = [1, LINE_HEIGHT, PAGE_HEIGHT]\n\nexport function normalizeWheel(e: WheelEventData): NormalizedWheel {\n  const deltaX = e.deltaX * DELTA_MODE_UNIT[e.deltaMode]\n  const deltaY = e.deltaY * DELTA_MODE_UNIT[e.deltaMode]\n  const deltaZ = (e.deltaZ || 0) * DELTA_MODE_UNIT[e.deltaMode]\n\n  return {\n    timeStamp: e.timeStamp,\n    axisDelta: [deltaX, deltaY, deltaZ],\n  }\n}\n\nconst reverseAll = [-1, -1, -1]\n\nexport function reverseAxisDeltaSign<T extends Pick<NormalizedWheel, 'axisDelta'>>(\n  wheel: T,\n  reverseSign: ReverseSign\n): T {\n  if (!reverseSign) {\n    return wheel\n  }\n\n  const multipliers = reverseSign === true ? reverseAll : reverseSign.map((shouldReverse) => (shouldReverse ? -1 : 1))\n\n  return {\n    ...wheel,\n    axisDelta: wheel.axisDelta.map((delta, i) => delta * multipliers[i]),\n  }\n}\n\nconst DELTA_MAX_ABS = 700\n\nexport const clampAxisDelta = <T extends Pick<NormalizedWheel, 'axisDelta'>>(wheel: T) => {\n  return {\n    ...wheel,\n    axisDelta: wheel.axisDelta.map((delta) => clamp(delta, -DELTA_MAX_ABS, DELTA_MAX_ABS)),\n  }\n}\n","import { WheelGesturesConfig } from '../types'\nimport { deepFreeze } from '../utils'\n\nexport const configDefaults: WheelGesturesConfig = deepFreeze({\n  preventWheelAction: true,\n  reverseSign: [true, true, false],\n})\n","import EventBus from '../events/EventBus'\nimport { WheelTargetObserver } from '../events/WheelTargetObserver'\nimport {\n  VectorXYZ,\n  WheelEventData,\n  WheelEventState,\n  WheelGesturesConfig,\n  WheelGesturesEventMap,\n  WheelGesturesOptions,\n} from '../types'\nimport { absMax, addVectors, average, deepFreeze, lastOf, projection } from '../utils'\nimport { clampAxisDelta, normalizeWheel, reverseAxisDeltaSign } from '../wheel-normalizer/wheel-normalizer'\nimport { __DEV__, ACC_FACTOR_MAX, ACC_FACTOR_MIN, WHEELEVENTS_TO_ANALAZE, WHEELEVENTS_TO_MERGE } from './constants'\nimport { configDefaults } from './options'\nimport { createWheelGesturesState } from './state'\n\nexport function WheelGestures(optionsParam: WheelGesturesOptions = {}) {\n  const { on, off, dispatch } = EventBus<WheelGesturesEventMap>()\n  let config = configDefaults\n  let state = createWheelGesturesState()\n  let currentEvent: WheelEventData\n  let negativeZeroFingerUpSpecialEvent = false\n  let prevWheelEventState: WheelEventState | undefined\n\n  const feedWheel = (wheelEvents: WheelEventData | WheelEventData[]) => {\n    if (Array.isArray(wheelEvents)) {\n      wheelEvents.forEach((wheelEvent) => processWheelEventData(wheelEvent))\n    } else {\n      processWheelEventData(wheelEvents)\n    }\n  }\n\n  const updateOptions = (newOptions: WheelGesturesOptions = {}): WheelGesturesConfig => {\n    if (Object.values(newOptions).some((option) => option === undefined || option === null)) {\n      __DEV__ && console.error('updateOptions ignored! undefined & null options not allowed')\n      return config\n    }\n    return (config = deepFreeze({ ...configDefaults, ...config, ...newOptions }))\n  }\n\n  const publishWheel = (additionalData?: Partial<WheelEventState>) => {\n    const wheelEventState: WheelEventState = {\n      event: currentEvent,\n      isStart: false,\n      isEnding: false,\n      isMomentumCancel: false,\n      isMomentum: state.isMomentum,\n      axisDelta: [0, 0, 0],\n      axisVelocity: state.axisVelocity,\n      axisMovement: state.axisMovement,\n      get axisMovementProjection() {\n        return addVectors(\n          wheelEventState.axisMovement,\n          wheelEventState.axisVelocity.map((velocity) => projection(velocity)) as VectorXYZ\n        )\n      },\n      ...additionalData,\n    }\n\n    dispatch('wheel', {\n      ...wheelEventState,\n      previous: prevWheelEventState,\n    })\n\n    // keep reference without previous, otherwise we would create a long chain\n    prevWheelEventState = wheelEventState\n  }\n\n  // should prevent when there is mainly movement on the desired axis\n  const shouldPreventDefault = (deltaMaxAbs: number, axisDelta: VectorXYZ): boolean => {\n    const { preventWheelAction } = config\n    const [deltaX, deltaY, deltaZ] = axisDelta\n\n    if (typeof preventWheelAction === 'boolean') return preventWheelAction\n\n    switch (preventWheelAction) {\n      case 'x':\n        return Math.abs(deltaX) >= deltaMaxAbs\n      case 'y':\n        return Math.abs(deltaY) >= deltaMaxAbs\n      case 'z':\n        return Math.abs(deltaZ) >= deltaMaxAbs\n      default:\n        __DEV__ && console.warn('unsupported preventWheelAction value: ' + preventWheelAction, 'warn')\n        return false\n    }\n  }\n\n  const processWheelEventData = (wheelEvent: WheelEventData) => {\n    const { axisDelta, timeStamp } = clampAxisDelta(\n      reverseAxisDeltaSign(normalizeWheel(wheelEvent), config.reverseSign)\n    )\n    const deltaMaxAbs = absMax(axisDelta)\n\n    if (wheelEvent.preventDefault && shouldPreventDefault(deltaMaxAbs, axisDelta)) {\n      wheelEvent.preventDefault()\n    }\n\n    if (!state.isStarted) {\n      start()\n    }\n    // check if user started scrolling again -> cancel\n    else if (state.isMomentum && deltaMaxAbs > Math.max(2, state.lastAbsDelta * 2)) {\n      end(true)\n      start()\n    }\n\n    // special finger up event on windows + blink\n    if (deltaMaxAbs === 0 && Object.is && Object.is(wheelEvent.deltaX, -0)) {\n      negativeZeroFingerUpSpecialEvent = true\n      // return -> zero delta event should not influence velocity\n      return\n    }\n\n    currentEvent = wheelEvent\n    state.axisMovement = addVectors(state.axisMovement, axisDelta)\n    state.lastAbsDelta = deltaMaxAbs\n    state.scrollPointsToMerge.push({\n      axisDelta,\n      timeStamp,\n    })\n\n    mergeScrollPointsCalcVelocity()\n\n    // only wheel event (move) and not start/end get the delta values\n    publishWheel({ axisDelta, isStart: !state.isStartPublished }) // state.isMomentum ? MOMENTUM_WHEEL : WHEEL, { axisDelta })\n\n    // publish start after velocity etc. have been updated\n    state.isStartPublished = true\n\n    // calc debounced end function, to recognize end of wheel event stream\n    willEnd()\n  }\n\n  const mergeScrollPointsCalcVelocity = () => {\n    if (state.scrollPointsToMerge.length === WHEELEVENTS_TO_MERGE) {\n      state.scrollPoints.unshift({\n        axisDeltaSum: state.scrollPointsToMerge.map((b) => b.axisDelta).reduce(addVectors),\n        timeStamp: average(state.scrollPointsToMerge.map((b) => b.timeStamp)),\n      })\n\n      // only update velocity after a merged scrollpoint was generated\n      updateVelocity()\n\n      // reset toMerge array\n      state.scrollPointsToMerge.length = 0\n\n      // after calculation of velocity only keep the most recent merged scrollPoint\n      state.scrollPoints.length = 1\n\n      if (!state.isMomentum) {\n        detectMomentum()\n      }\n    } else if (!state.isStartPublished) {\n      updateStartVelocity()\n    }\n  }\n\n  const updateStartVelocity = () => {\n    state.axisVelocity = lastOf(state.scrollPointsToMerge).axisDelta.map((d) => d / state.willEndTimeout) as VectorXYZ\n  }\n\n  const updateVelocity = () => {\n    // need to have two recent points to calc velocity\n    const [latestScrollPoint, prevScrollPoint] = state.scrollPoints\n\n    if (!prevScrollPoint || !latestScrollPoint) {\n      return\n    }\n\n    // time delta\n    const deltaTime = latestScrollPoint.timeStamp - prevScrollPoint.timeStamp\n\n    if (deltaTime <= 0) {\n      __DEV__ && console.warn('invalid deltaTime')\n      return\n    }\n\n    // calc the velocity per axes\n    const velocity = latestScrollPoint.axisDeltaSum.map((d) => d / deltaTime) as VectorXYZ\n\n    // calc the acceleration factor per axis\n    const accelerationFactor = velocity.map((v, i) => v / (state.axisVelocity[i] || 1))\n\n    state.axisVelocity = velocity\n    state.accelerationFactors.push(accelerationFactor)\n\n    updateWillEndTimeout(deltaTime)\n  }\n\n  const updateWillEndTimeout = (deltaTime: number) => {\n    // use current time between events rounded up and increased by a bit as timeout\n    let newTimeout = Math.ceil(deltaTime / 10) * 10 * 1.2\n\n    // double the timeout, when momentum was not detected yet\n    if (!state.isMomentum) {\n      newTimeout = Math.max(100, newTimeout * 2)\n    }\n\n    state.willEndTimeout = Math.min(1000, Math.round(newTimeout))\n  }\n\n  const accelerationFactorInMomentumRange = (accFactor: number) => {\n    // when main axis is the the other one and there is no movement/change on the current one\n    if (accFactor === 0) return true\n    return accFactor <= ACC_FACTOR_MAX && accFactor >= ACC_FACTOR_MIN\n  }\n\n  const detectMomentum = () => {\n    if (state.accelerationFactors.length >= WHEELEVENTS_TO_ANALAZE) {\n      if (negativeZeroFingerUpSpecialEvent) {\n        negativeZeroFingerUpSpecialEvent = false\n\n        if (absMax(state.axisVelocity) >= 0.2) {\n          recognizedMomentum()\n          return\n        }\n      }\n\n      const recentAccelerationFactors = state.accelerationFactors.slice(WHEELEVENTS_TO_ANALAZE * -1)\n\n      // check recent acceleration / deceleration factors\n      // all recent need to match, if any did not match\n      const detectedMomentum = recentAccelerationFactors.every((accFac) => {\n        // when both axis decelerate exactly in the same rate it is very likely caused by momentum\n        const sameAccFac = !!accFac.reduce((f1, f2) => (f1 && f1 < 1 && f1 === f2 ? 1 : 0))\n\n        // check if acceleration factor is within momentum range\n        const bothAreInRangeOrZero = accFac.filter(accelerationFactorInMomentumRange).length === accFac.length\n\n        // one the requirements must be fulfilled\n        return sameAccFac || bothAreInRangeOrZero\n      })\n\n      if (detectedMomentum) {\n        recognizedMomentum()\n      }\n\n      // only keep the most recent events\n      state.accelerationFactors = recentAccelerationFactors\n    }\n  }\n\n  const recognizedMomentum = () => {\n    state.isMomentum = true\n  }\n\n  const start = () => {\n    state = createWheelGesturesState()\n    state.isStarted = true\n    state.startTime = Date.now()\n    prevWheelEventState = undefined\n    negativeZeroFingerUpSpecialEvent = false\n  }\n\n  const willEnd = (() => {\n    let willEndId: number\n    return () => {\n      clearTimeout(willEndId)\n      willEndId = setTimeout(end, state.willEndTimeout)\n    }\n  })()\n\n  const end = (isMomentumCancel = false) => {\n    if (!state.isStarted) return\n\n    if (state.isMomentum && isMomentumCancel) {\n      publishWheel({ isEnding: true, isMomentumCancel: true })\n    } else {\n      publishWheel({ isEnding: true })\n    }\n\n    state.isMomentum = false\n    state.isStarted = false\n  }\n\n  const { observe, unobserve, disconnect } = WheelTargetObserver(feedWheel)\n\n  updateOptions(optionsParam)\n\n  return deepFreeze({\n    on,\n    off,\n    observe,\n    unobserve,\n    disconnect,\n    feedWheel,\n    updateOptions,\n  })\n}\n","import { deepFreeze } from '../utils'\n\nexport type EventMapEmpty = Record<string, unknown>\nexport type EventListener<D = unknown> = (data: D) => void\nexport type Off = () => void\n\nexport default function EventBus<EventMap = EventMapEmpty>() {\n  const listeners = {} as Record<keyof EventMap, EventListener<never>[]>\n\n  function on<EK extends keyof EventMap>(type: EK, listener: EventListener<EventMap[EK]>): Off {\n    listeners[type] = (listeners[type] || []).concat(listener)\n    return () => off(type, listener)\n  }\n\n  function off<EK extends keyof EventMap>(type: EK, listener: EventListener<EventMap[EK]>) {\n    listeners[type] = (listeners[type] || []).filter((l) => l !== listener)\n  }\n\n  function dispatch<EK extends keyof EventMap>(type: EK, data: EventMap[EK]) {\n    if (!(type in listeners)) return\n    ;(listeners[type] as EventListener<EventMap[EK]>[]).forEach((l) => l(data))\n  }\n\n  return deepFreeze({\n    on,\n    off,\n    dispatch,\n  })\n}\n","/**\n * the timeout is automatically adjusted during a gesture\n * the initial timeout period is pretty long, so even old mouses, which emit wheel events less often, can produce a continuous gesture\n */\nimport { WheelGesturesInternalState } from './internal-types'\n\nconst WILL_END_TIMEOUT_DEFAULT = 400\n\nexport function createWheelGesturesState(): WheelGesturesInternalState {\n  return {\n    isStarted: false,\n    isStartPublished: false,\n    isMomentum: false,\n    startTime: 0,\n    lastAbsDelta: Infinity,\n    axisMovement: [0, 0, 0],\n    axisVelocity: [0, 0, 0],\n    accelerationFactors: [],\n    scrollPoints: [],\n    scrollPointsToMerge: [],\n    willEndTimeout: WILL_END_TIMEOUT_DEFAULT,\n  }\n}\n","export const __DEV__ = process.env.NODE_ENV !== 'production'\nexport const ACC_FACTOR_MIN = 0.6\nexport const ACC_FACTOR_MAX = 0.96\nexport const WHEELEVENTS_TO_MERGE = 2\nexport const WHEELEVENTS_TO_ANALAZE = 5\n","import { WheelEventData } from '../types'\nimport { deepFreeze } from '../utils'\n\ntype UnobserveTarget = () => void\n\nexport function WheelTargetObserver(eventListener: (wheelEvent: WheelEventData) => void) {\n  let targets: EventTarget[] = []\n\n  // add event listener to target element\n  const observe = (target: EventTarget): UnobserveTarget => {\n    target.addEventListener('wheel', eventListener as EventListener, { passive: false })\n    targets.push(target)\n\n    return () => unobserve(target)\n  }\n\n  /// remove event listener from target element\n  const unobserve = (target: EventTarget) => {\n    target.removeEventListener('wheel', eventListener as EventListener)\n    targets = targets.filter((t) => t !== target)\n  }\n\n  // stops watching all of its target elements for visibility changes.\n  const disconnect = () => {\n    targets.forEach(unobserve)\n  }\n\n  return deepFreeze({\n    observe,\n    unobserve,\n    disconnect,\n  })\n}\n"],"names":["projection","velocityPxMs","decay","lastOf","array","length","average","numbers","reduce","a","b","clamp","value","min","max","Math","addVectors","v1","v2","Error","map","val","i","absMax","abs","deepFreeze","o","Object","freeze","values","forEach","isFrozen","DELTA_MODE_UNIT","window","innerHeight","reverseAll","configDefaults","preventWheelAction","reverseSign","WheelGestures","optionsParam","currentEvent","prevWheelEventState","willEndId","listeners","off","type","listener","filter","l","on","concat","dispatch","data","EventBus","config","state","isStarted","isStartPublished","isMomentum","startTime","lastAbsDelta","Infinity","axisMovement","axisVelocity","accelerationFactors","scrollPoints","scrollPointsToMerge","willEndTimeout","negativeZeroFingerUpSpecialEvent","feedWheel","wheelEvents","Array","isArray","wheelEvent","processWheelEventData","updateOptions","newOptions","some","option","publishWheel","additionalData","wheelEventState","event","isStart","isEnding","isMomentumCancel","axisDelta","velocity","previous","e","wheel","delta","clampAxisDelta","multipliers","shouldReverse","reverseAxisDeltaSign","timeStamp","deltaX","deltaMode","deltaY","deltaZ","deltaMaxAbs","preventDefault","shouldPreventDefault","end","start","is","push","mergeScrollPointsCalcVelocity","willEnd","unshift","axisDeltaSum","updateVelocity","detectMomentum","updateStartVelocity","d","latestScrollPoint","prevScrollPoint","deltaTime","accelerationFactor","v","updateWillEndTimeout","newTimeout","ceil","round","accelerationFactorInMomentumRange","accFactor","recognizedMomentum","recentAccelerationFactors","slice","WHEELEVENTS_TO_ANALAZE","every","accFac","sameAccFac","f1","f2","bothAreInRangeOrZero","Date","now","undefined","clearTimeout","setTimeout","eventListener","targets","unobserve","target","removeEventListener","t","observe","addEventListener","passive","disconnect","WheelTargetObserver"],"mappings":"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"}