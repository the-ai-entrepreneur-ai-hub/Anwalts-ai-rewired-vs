{"version":3,"file":"dedent.umd.js","sources":["../src/dedent.ts"],"sourcesContent":["type Tag<A extends unknown[], R, T> = (\n  this: T,\n  strings: TemplateStringsArray,\n  ...substitutions: A\n) => R;\n\nconst cache = new WeakMap<TemplateStringsArray, TemplateStringsArray>();\nconst newline = /(\\n|\\r\\n?|\\u2028|\\u2029)/g;\nconst leadingWhitespace = /^\\s*/;\nconst nonWhitespace = /\\S/;\nconst slice = Array.prototype.slice;\n\nconst zero = '0'.charCodeAt(0);\nconst nine = '9'.charCodeAt(0);\nconst lowerA = 'a'.charCodeAt(0);\nconst lowerF = 'f'.charCodeAt(0);\nconst upperA = 'A'.charCodeAt(0);\nconst upperF = 'F'.charCodeAt(0);\n\nfunction dedent(str: string): string;\nfunction dedent(str: TemplateStringsArray, ...substitutions: unknown[]): string;\nfunction dedent<A extends unknown[], R, T>(tag: Tag<A, R, T>): Tag<A, R, T>;\nfunction dedent<A extends unknown[], R, T>(\n  arg: string | TemplateStringsArray | Tag<A, R, T>,\n): string | Tag<A, R, T> {\n  if (typeof arg === 'string') {\n    return process([arg])[0];\n  }\n\n  if (typeof arg === 'function') {\n    return function () {\n      const args = slice.call(arguments);\n      args[0] = processTemplateStringsArray(args[0]);\n      return (arg as any).apply(this, args);\n    } as Tag<A, R, T>;\n  }\n\n  const strings = processTemplateStringsArray(arg);\n  // TODO: This is just `String.cooked`: https://tc39.es/proposal-string-cooked/\n  let s = getCooked(strings, 0);\n  for (let i = 1; i < strings.length; i++) {\n    s += arguments[i] + getCooked(strings, i);\n  }\n  return s;\n}\n\nfunction getCooked(strings: readonly (string | undefined)[], index: number): string {\n  const str = strings[index];\n  if (str === undefined) throw new TypeError(`invalid cooked string at index ${index}`);\n  return str;\n}\n\nfunction processTemplateStringsArray(strings: TemplateStringsArray): TemplateStringsArray {\n  const cached = cache.get(strings);\n  if (cached) return cached;\n\n  const raw = process(strings.raw);\n  const cooked = raw.map(cook) as unknown as TemplateStringsArray;\n\n  Object.defineProperty(cooked, 'raw', {\n    value: Object.freeze(raw),\n  });\n  Object.freeze(cooked);\n  cache.set(strings, cooked);\n\n  return cooked;\n}\n\nfunction process(strings: readonly string[]): readonly string[] {\n  // splitQuasis is an array of arrays. The inner array is contains text content lines on the\n  // even indices, and the newline char that ends the text content line on the odd indices.\n  // In the first array, the inner array's 0 index is the opening line of the template literal.\n  // In all other arrays, the inner array's 0 index is the continuation of the line directly after a\n  // template expression.\n  //\n  // Eg, in the following case:\n  //\n  // ```\n  // String.dedent`\n  //   first\n  //   ${expression} second\n  //   third\n  // `\n  // ```\n  //\n  // We expect the following splitQuasis:\n  //\n  // ```\n  // [\n  //   [\"\", \"\\n\", \"  first\", \"\\n\", \"  \"],\n  //   [\" second\", \"\\n\", \"  third\", \"\\n\", \"\"],\n  // ]\n  // ```\n  const splitQuasis = strings.map((quasi) => quasi.split(newline));\n\n  let common;\n  for (let i = 0; i < splitQuasis.length; i++) {\n    const lines = splitQuasis[i];\n\n    // The first split is the static text starting at the opening line until the first template\n    // expression (or the end of the template if there are no expressions).\n    const firstSplit = i === 0;\n\n    // The last split is all the static text after the final template expression until the closing\n    // line. If there are no template expressions, then the first split is also the last split.\n    const lastSplit = i + 1 === splitQuasis.length;\n\n    // The opening line must be empty (it very likely is) and it must not contain a template\n    // expression. The opening line's trailing newline char is removed.\n    if (firstSplit) {\n      // Length > 1 ensures there is a newline, and there is not a template expression.\n      if (lines.length === 1 || lines[0].length > 0) {\n        throw new Error('invalid content on opening line');\n      }\n      // Clear the captured newline char.\n      lines[1] = '';\n    }\n\n    // The closing line may only contain whitespace and must not contain a template expression. The\n    // closing line and its preceding newline are removed.\n    if (lastSplit) {\n      // Length > 1 ensures there is a newline, and there is not a template expression.\n      if (lines.length === 1 || nonWhitespace.test(lines[lines.length - 1])) {\n        throw new Error('invalid content on closing line');\n      }\n      // Clear the captured newline char, and the whitespace on the closing line.\n      lines[lines.length - 2] = '';\n      lines[lines.length - 1] = '';\n    }\n\n    // In the first spit, the index 0 is the opening line (which must be empty by now), and in all\n    // other splits, its the content trailing the template expression (and so can't be part of\n    // leading whitespace).\n    // Every odd index is the captured newline char, so we'll skip and only process evens.\n    for (let j = 2; j < lines.length; j += 2) {\n      const text = lines[j];\n\n      // If we are on the last line of this split, and we are not processing the last split (which\n      // is after all template expressions), then this line contains a template expression.\n      const lineContainsTemplateExpression = j + 1 === lines.length && !lastSplit;\n\n      // leadingWhitespace is guaranteed to match something, but it could be 0 chars.\n      const leading = leadingWhitespace.exec(text)![0];\n\n      // Empty lines do not affect the common indentation, and whitespace only lines are emptied\n      // (and also don't affect the comon indentation).\n      if (!lineContainsTemplateExpression && leading.length === text.length) {\n        lines[j] = '';\n        continue;\n      }\n\n      common = commonStart(leading, common);\n    }\n  }\n\n  const min = common ? common.length : 0;\n  return splitQuasis.map((lines) => {\n    let quasi = lines[0];\n    for (let i = 1; i < lines.length; i += 2) {\n      const newline = lines[i];\n      const text = lines[i + 1];\n      quasi += newline + text.slice(min);\n    }\n    return quasi;\n  });\n}\n\nfunction commonStart(a: string, b: string | undefined): string {\n  if (b === undefined || a === b) return a;\n  let i = 0;\n  for (const len = Math.min(a.length, b.length); i < len; i++) {\n    if (a[i] !== b[i]) break;\n  }\n  return a.slice(0, i);\n}\n\nfunction cook(raw: string): string | undefined {\n  let out = '';\n  let start = 0;\n\n  // We need to find every backslash escape sequence, and cook the escape into a real char.\n  let i = 0;\n  while ((i = raw.indexOf('\\\\', i)) > -1) {\n    out += raw.slice(start, i);\n\n    // If the backslash is the last char of the string, then it was an invalid sequence.\n    // This can't actually happen in a tagged template literal, but could happen if you manually\n    // invoked the tag with an array.\n    if (++i === raw.length) return undefined;\n\n    const next = raw[i++];\n    switch (next) {\n      // Escaped control codes need to be individually processed.\n      case 'b':\n        out += '\\b';\n        break;\n      case 't':\n        out += '\\t';\n        break;\n      case 'n':\n        out += '\\n';\n        break;\n      case 'v':\n        out += '\\v';\n        break;\n      case 'f':\n        out += '\\f';\n        break;\n      case 'r':\n        out += '\\r';\n        break;\n\n      // Escaped line terminators just skip the char.\n      case '\\r':\n        // Treat `\\r\\n` as a single terminator.\n        if (i < raw.length && raw[i] === '\\n') ++i;\n      // fall through\n      case '\\n':\n      case '\\u2028':\n      case '\\u2029':\n        break;\n\n      // `\\0` is a null control char, but `\\0` followed by another digit is an illegal octal escape.\n      case '0':\n        if (isDigit(raw, i)) return undefined;\n        out += '\\0';\n        break;\n\n      // Hex escapes must contain 2 hex chars.\n      case 'x': {\n        const n = parseHex(raw, i, i + 2);\n        if (n === -1) return undefined;\n        i += 2;\n        out += String.fromCharCode(n);\n        break;\n      }\n\n      // Unicode escapes contain either 4 chars, or an unlimited number between `{` and `}`.\n      // The hex value must not overflow 0x10ffff.\n      case 'u': {\n        let n;\n        if (i < raw.length && raw[i] === '{') {\n          const end = raw.indexOf('}', ++i);\n          if (end === -1) return undefined;\n\n          n = parseHex(raw, i, end);\n          i = end + 1;\n        } else {\n          n = parseHex(raw, i, i + 4);\n          i += 4;\n        }\n        if (n === -1 || n > 0x10ffff) return undefined;\n\n        out += String.fromCodePoint(n);\n        break;\n      }\n\n      default:\n        if (isDigit(next, 0)) return undefined;\n        out += next;\n    }\n\n    start = i;\n  }\n\n  return out + raw.slice(start);\n}\n\nfunction isDigit(str: string, index: number): boolean {\n  const c = str.charCodeAt(index);\n  return c >= zero && c <= nine;\n}\n\nfunction parseHex(str: string, index: number, end: number): number {\n  if (end >= str.length) return -1;\n\n  let n = 0;\n  for (; index < end; index++) {\n    const c = hexToInt(str.charCodeAt(index));\n    if (c === -1) return -1;\n    n = n * 16 + c;\n  }\n  return n;\n}\n\nfunction hexToInt(c: number): number {\n  if (c >= zero && c <= nine) return c - zero;\n  if (c >= lowerA && c <= lowerF) return c - lowerA + 10;\n  if (c >= upperA && c <= upperF) return c - upperA + 10;\n  return -1;\n}\n\nexport default dedent;\n"],"names":[],"mappings":"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"}